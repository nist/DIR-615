/*
 * Note: this file originally auto-generated by mib2c using
 *        : mib2c.scalar.conf,v 1.7 2003/04/08 14:57:04 dts12 Exp $
 */

#include <net-snmp/net-snmp-config.h>
#include <net-snmp/net-snmp-includes.h>
#include <net-snmp/agent/net-snmp-agent-includes.h>
#include <string.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include "dlink.h"

/*define initial value, we will replace them with nvram default after
 *we get the broad
*/
#define SYSTEMMODELNAME "DWL-3250"
#define SYSTEMFIRMWAREVERSION "1.0"
#define SYSTEMHWID "1234567890"
#define U_INT unsigned long int
#define WANMACLENGTH 6
/** Initializes the dlink module */

U_INT system_time = 0;
U_INT system_uptime = 0;
U_INT system_reboot = 0;
U_INT system_admin = 0;
U_INT system_console = 0;
U_INT system_console_timeout = 0;
U_INT system_restore = 0;
U_INT system_ntp_time_zone = 0;
U_INT system_ntp_daylight_saving = 0;
U_INT system_ntp_start_month = 1;
U_INT system_ntp_start_week = 1;
U_INT system_ntp_start_day = 1;
U_INT system_ntp_start_time = 1;
U_INT system_ntp_end_month = 2;
U_INT system_ntp_end_week = 2;
U_INT system_ntp_end_day = 2;
U_INT system_ntp_end_time = 2;
U_INT wireless_channel = 6;
U_INT wireless_data_rate = 0;
U_INT wireless_fragment_length = 1000;
U_INT wireless_RTS_length = 1000;
U_INT wireless_transmit_power = 1;
U_INT wireless_bgmode = 0;
U_INT wireless_connected_time = 0;
U_INT wireless_antenna = 0;
U_INT wireless_authtype = 0;
U_INT wireless_wepkey_type = 0;
U_INT wireless_wepkey_size = 0;
U_INT wireless_valid_key = 1;
U_INT wireless_wpa_eap_type = 0;
U_INT wireless_wpa_auth_type = 0;
U_INT wan_connected_mode = 0;
U_INT wan_clone_mac = 0;
U_INT wan_mtu = 1500;
U_INT wan_tx_frame_count = 0;
U_INT wan_tx_multicast_frame_count = 0;
U_INT wan_tx_error_frame_count = 0;
U_INT wan_rx_frame_count = 0;
U_INT wan_rx_multicast_frame_count = 0;
U_INT wan_rx_error_frame_count = 0;
U_INT advance_upnp = 0;
U_INT advance_ping_respond = 0;
U_INT advance_multicast = 0;
U_INT advance_ddns = 0;
U_INT advance_server_address = 0;
U_INT advance_pptp_passthrough = 0;
U_INT advance_l2tp_passthrough = 0;
U_INT advance_ipsec_passthrough = 0;
U_INT advance_mac_filter_type = 0;
U_INT advance_web_filter_type = 0;
U_INT lan_dns_relay = 0;
U_INT lan_tx_frame_count = 0;
U_INT lan_tx_multicast_frame_count = 0;
U_INT lan_tx_error_frame_count = 0;
U_INT lan_rx_frame_count = 0;
U_INT lan_rx_multicast_frame_count = 0;
U_INT lan_rx_error_frame_count = 0;
U_INT lan_dhcp = 0;
U_INT lan_dhcp_start_ip = 1;
U_INT lan_dhcp_end_ip = 254;
U_INT lan_dhcp_lease_time = 86400;
U_INT lan_dhcp_dns_relay = 0;
char wan_mac[WANMACLENGTH] = {0,0,0,0,0,0};
char wep_key_one[64] = "3131313131";
char wep_key_two[64] = "3232323232";
char wep_key_three[64] = "3333333333";
char wep_key_four[64] = "3434343434";
/*******************************************************
* check IP range : 1.0.0.0 - 253.255.255.255
*******************************************************/
int check_illegal_ip(char *ipaddress)
{
	int temp_ip_token[4];
	sscanf(ipaddress,"%d.%d.%d.%d",&temp_ip_token[0],&temp_ip_token[1],&temp_ip_token[2],&temp_ip_token[3]);
	if((temp_ip_token[0] > 253) || (temp_ip_token[0] <= 0))
		return -1;
	else
		return 0;
}

int check_hex(char *input)
{
	int i,j;
	char temp[64]=" ";

	for (i = 0 ; i < strlen(input) ; i++)
	{
		sprintf(temp,"%d\n",input[i]);
		j = atoi(temp);
		if(!((j < 58 && j > 47 ) || (j < 71 && j > 64) || (j < 103 && j > 96)))
			return 0;
	}
		return 1;
}

char *hex_to_ascii(char *input)
{
	char temp[1024] = "";
	char temp1[4] = "";
        char temp2[1024] = "";

	int i,j;
	for(i=0;i<strlen(input);i++)
	{
		sprintf(temp,"%d",input[i]);
		j=atoi(temp);
		sprintf(temp1,"%c",j);
		strcat(temp2,temp1);	
	}
	return temp2;

}


char *ascii_to_hex(char *input)
{
	char temp[1024] = "";
	char temp1[4] = "";
	char temp2[1024] = "";
	int i,j;
	for(i=0;i<strlen(input);i++)
	{
		sprintf(temp,"%d",input[i]);
		j=atoi(temp);
		sprintf(temp1,"%x",j);
		strcat(temp2,temp1);
	}
	return temp2;
}

void modify_wep_key_by_index(int wep_key_index,char *wepkey,int key_size,netsnmp_agent_request_info *reqinfo,netsnmp_request_info *requests)
{
	if(key_size == 64)
	{
		if(wep_key_index == 1)
			memcpy(wep_key_one,wepkey,requests->requestvb->val_len);
		if(wep_key_index == 2)
			memcpy(wep_key_two,wepkey,requests->requestvb->val_len);
		if(wep_key_index == 3)
			memcpy(wep_key_three,wepkey,requests->requestvb->val_len);
		if(wep_key_index == 4)
			memcpy(wep_key_four,wepkey,requests->requestvb->val_len);
	}
		
}

void check_wep_input_format(int wep_key_index,char *wepkey, netsnmp_agent_request_info *reqinfo,netsnmp_request_info *requests)
{
	if(wireless_wepkey_type == 0)
        {
                if(wireless_wepkey_size == 0)/*HEX-64*/
                {
			if((requests->requestvb->val_len) != 10)
                                netsnmp_set_request_error(reqinfo, requests,SNMP_ERR_WRONGVALUE);
			else if(!check_hex(wepkey))
                                        netsnmp_set_request_error(reqinfo, requests,SNMP_ERR_WRONGVALUE);
				else
					modify_wep_key_by_index(wep_key_index,wepkey,64,reqinfo, requests);		  
                }
                else
                if(wireless_wepkey_size == 1)/*HEX-128*/
                {
                        if(strlen(wepkey) != 26)
                        {
                                netsnmp_set_request_error(reqinfo, requests,SNMP_ERR_WRONGVALUE);
                                if(!check_hex(wepkey))
                                        netsnmp_set_request_error(reqinfo, requests,SNMP_ERR_WRONGVALUE);
                        }
                }
                else
                if(wireless_wepkey_size == 2)/*HEX-128*/
                {
                        if(strlen(wepkey) != 32)
                        {
                                netsnmp_set_request_error(reqinfo, requests,SNMP_ERR_WRONGVALUE);
                                if(!check_hex(wepkey))
                                        netsnmp_set_request_error(reqinfo, requests,SNMP_ERR_WRONGVALUE);
                        }
                }
        }
        else
        if(wireless_wepkey_type == 1)
        {
                if(wireless_wepkey_size == 0)/*ASCII-64*/
                         if(strlen(wepkey) != 5)
                                netsnmp_set_request_error(reqinfo, requests,SNMP_ERR_WRONGVALUE);
                if(wireless_wepkey_size == 1)/*ASCII-128*/
                         if(strlen(wepkey) != 10)
                                netsnmp_set_request_error(reqinfo, requests,SNMP_ERR_WRONGVALUE);
                if(wireless_wepkey_size == 2)/*ASCII-152*/
                         if(strlen(wepkey) != 16)
                                netsnmp_set_request_error(reqinfo, requests,SNMP_ERR_WRONGVALUE);
        }

}

char *mac_complement(char *mac,char *result){
        char tmp_1[3] = {};
        char tmp_2[3] = {};
        char start[20] = {};
        int i=0;
        memcpy(start,mac,strlen(mac));
        strcat(start,":");
        for(i=0; i<strlen(mac);){
                tmp_1[0] = start[i];
                tmp_2[0] = start[i+1];
                if(strcmp(tmp_1,":") == 0 )
                        return NULL;
                else if(strcmp(tmp_2,":") == 0) {
                        sprintf(result,"%s%s%s%s",result,"0",tmp_1,":");
                        i = i + 2 ;
                }else {
                        sprintf(result,"%s%s%s%s",result,tmp_1,tmp_2,":");
                        i = i+3;
                }
                memset(tmp_1,0,3);
                memset(tmp_2,0,3);
        }
        *(strrchr(result,':')) = '\0';
        return result;
}


int mac_check(char *mac){                   
        char *start = NULL;
        char tmp[6] = {};       
        int i=0;
        char res[20] = {};
       
        if(strlen(mac) < 17){ // if < 17 is likely "1:2:3:4:5:6"
                start = mac_complement(mac,res);               
                if(strlen(start) != 17)
                        return 0;
        }else if(strlen(mac) == 17)                                                                             // check len ( 17 is correct )  ^M
                start = mac;
        else
                return 0;
        memcpy(tmp,start,3);          
        if(tmp[0] != '0')// mac filter : mac first 1 address must be 0x;^M
                return 0;
        if((tmp[0] != '0' || tmp[1] != '0')){               
                return 0;// wan type : mac first 2 address must be 00;
        }
        memset(tmp,0,6);  
        for(i=0; i<strlen(start); i++){// if format correct
                memcpy(tmp,start,1);   
                if(i == 2 || i == 5 || i == 8 || i == 11 || i == 14)
                        if(strcmp(tmp,":") == 0)                                                                        // check ":" position^M
                                goto move;
                        else              
                                return 0; 
                if(strcasecmp(tmp,"a") == 0 || strcasecmp(tmp,"b") == 0 || strcasecmp(tmp,"c") == 0 || strcasecmp(tmp,"d") == 0 || strcasecmp(tmp,"e") == 0 || strcasecmp(tmp,"f") == 0)    
                        goto move;// check "a to f"
                if(strcmp(tmp,"0") == 0)// check "0"^M
                                goto move;
                if(1 <= atoi(tmp) && atoi(tmp)<= 9)// check "1~9"                          
                                goto move;                      
                else{
			if(strcmp(tmp,":") == 0)// ignore ":"
                                goto move; 
 				return 0;
                }               
	move:           
		start++;
        }
        return 1;       
}

static int illegal_mask(char *mask_token){
	if( 0 >= strlen(mask_token) || strlen(mask_token) > 3 )  //     check length
		return 0;
        /* illegal netmask value */     
        if((strcmp(mask_token,"255") ==0) || (strcmp(mask_token,"254") ==0) ||
           (strcmp(mask_token,"252") ==0) || (strcmp(mask_token,"248") ==0) ||
           (strcmp(mask_token,"240") ==0) || (strcmp(mask_token,"224") ==0) ||
           (strcmp(mask_token,"192") ==0) || (strcmp(mask_token,"128") ==0) ||
           (strcmp(mask_token,"0") ==0) )
		return 1;
        else
                return 0;         
}


int netmask_check(char *address, char *token_1, char *token_2, char *token_3, char *token_4){
	/* check length & illegal value */
        if((illegal_mask(token_1) == 0) || (illegal_mask(token_2) == 0) || \
           (illegal_mask(token_3) == 0) || (illegal_mask(token_4) == 0) )   
        return 0;                                                                    
                                                                              
  if(strcmp(token_1,"255") == 0){                                           
        if(strcmp(token_2,"255") == 0){                                         
                if(strcmp(token_3,"255") == 0)                                  
                        return 1;                                               
                else{                                                           
                        strcat(token_1,".");                                    
                        strcat(token_1,token_2);                                
                        strcat(token_1,".");                                    
                        strcat(token_1,token_3);                                
                        strcat(token_1,".0");                                                                  
                        if(strcmp(token_1,address) != 0)   // should be 255.255.255.0       
                                return 0;                                                   
                }                                                                          
        }                                                                            
        else{                                                                        
                strcat(token_1,".");                                                 
                strcat(token_1,token_2);                                         
                strcat(token_1,".0.0");// should be 255.255.0.0         
                if(strcmp(token_1,address) != 0)                        
                        return 0;                                       
      }                                                                            
  }                                                                              
  else{                                                                          
        strcat(token_1,".0.0.0");// should be 255.0.0.0           
        if(strcmp(token_1,address) != 0)                                        
                return 0;                                                                  
  }                             
  return 1;
}

void
init_dlink(void)
{
	/*common information*/
    static oid      enterpriseModelName_oid[] =
        { 1, 3, 6, 1, 4, 1, 171, 1, 1, 1 };
    static oid      enterpriseSystemTime_oid[] =
        { 1, 3, 6, 1, 4, 1, 171, 1, 1, 2 };
    static oid      enterpriseUpTime_oid[] =
        { 1, 3, 6, 1, 4, 1, 171, 1, 1, 3 };
    static oid      enterpriseFirmwareVersion_oid[] =
        { 1, 3, 6, 1, 4, 1, 171, 1, 1, 4 };
    static oid      enterpriseHWID_oid[] =
        { 1, 3, 6, 1, 4, 1, 171, 1, 1, 5 };
    static oid      enterpriseSystemReboot_oid[] =
        { 1, 3, 6, 1, 4, 1, 171, 1, 1, 6 };
    static oid      enterpriseLimitAdmin_oid[] =
        { 1, 3, 6, 1, 4, 1, 171, 1, 1, 7 };
    static oid      enterpriseLimitAdminIP1_oid[] =
        { 1, 3, 6, 1, 4, 1, 171, 1, 1, 8 }; 
    static oid      enterpriseLimitAdminIP2_oid[] =
        { 1, 3, 6, 1, 4, 1, 171, 1, 1, 9 };
    static oid      enterpriseConsoleSettings_oid[] =
        { 1, 3, 6, 1, 4, 1, 171, 1, 1, 10 };
    static oid      enterpriseConsoleSettingsTimeout_oid[] =
        { 1, 3, 6, 1, 4, 1, 171, 1, 1, 11 };
    static oid      enterpriseSystemRestore_oid[] =
        { 1, 3, 6, 1, 4, 1, 171, 1, 1, 12 };
	/*NTP*/
    static oid      enterpriseNTPServerIP_oid[] =
        { 1, 3, 6, 1, 4, 1, 171, 1, 1, 13, 1 };
    static oid      enterpriseNTPTimeZone_oid[] =
        { 1, 3, 6, 1, 4, 1, 171, 1, 1, 13, 2 };
    static oid      EnterpriseNTPDaylightSaving_oid[] =
        { 1, 3, 6, 1, 4, 1, 171, 1, 1, 13, 3 };
    static oid      enterpriseStartMonth_oid[] =
        { 1, 3, 6, 1, 4, 1, 171, 1, 1, 13, 4, 1 };
    static oid      enterpriseStartWeek_oid[] =
        { 1, 3, 6, 1, 4, 1, 171, 1, 1, 13, 4, 2 };	
    static oid      enterpriseStartDayOfWeek_oid[] =
        { 1, 3, 6, 1, 4, 1, 171, 1, 1, 13, 4, 3 };
    static oid      enterpriseStartTime_oid[] =
        { 1, 3, 6, 1, 4, 1, 171, 1, 1, 13, 4, 4 };
    static oid      enterpriseEndMonth_oid[] =
        { 1, 3, 6, 1, 4, 1, 171, 1, 1, 13, 5, 1 };
    static oid      enterpriseEndWeek_oid[] =
        { 1, 3, 6, 1, 4, 1, 171, 1, 1, 13, 5, 2 };
    static oid      enterpriseEndDayOfWeek_oid[] =
        { 1, 3, 6, 1, 4, 1, 171, 1, 1, 13, 5, 3 };
    static oid      enterpriseEndTime_oid[] =
        { 1, 3, 6, 1, 4, 1, 171, 1, 1, 13, 5, 4 };
	/*wireless information*/
    static oid      enterpriseSSID_oid[] =
        { 1, 3, 6, 1, 4, 1, 171, 1, 2, 1, 1 };
    static oid      enterpriseChannel_oid[] =
        { 1, 3, 6, 1, 4, 1, 171, 1, 2, 1, 2 };   
    static oid      enterpriseDataRate_oid[] =
        { 1, 3, 6, 1, 4, 1, 171, 1, 2, 1, 3 };
    static oid      enterpriseFragmentLength_oid[] =
        { 1, 3, 6, 1, 4, 1, 171, 1, 2, 1, 4 };
    static oid      enterpriseRTSLength_oid[] =
        { 1, 3, 6, 1, 4, 1, 171, 1, 2, 1, 5 };
    static oid      enterpriseTransmitPower_oid[] =
        { 1, 3, 6, 1, 4, 1, 171, 1, 2, 1, 6 };
    static oid      enterpriseBGMode_oid[] =
        { 1, 3, 6, 1, 4, 1, 171, 1, 2, 1, 7 };
    static oid      enterpriseAntennaDiversity_oid[] =
        { 1, 3, 6, 1, 4, 1, 171, 1, 2, 1, 8 };
    static oid      enterpriseConnectedTime_oid[] =
        { 1, 3, 6, 1, 4, 1, 171, 1, 2, 1, 9 };	
	/*wireless security*/
	/* WEP */
    static oid      dlkWirelessAuthenticationType_oid[] =
        { 1, 3, 6, 1, 4, 1, 171, 1, 2, 2, 1 };
    static oid      dlkWirelessWEPKeyType_oid[] =
        { 1, 3, 6, 1, 4, 1, 171, 1, 2, 2, 2 };
    static oid      dlkWirelessWEPKeySize_oid[] =
        { 1, 3, 6, 1, 4, 1, 171, 1, 2, 2, 3 };
    static oid      dlkWirelessWEPValidKey_oid[] =
        { 1, 3, 6, 1, 4, 1, 171, 1, 2, 2, 4 };
    static oid      dlkWirelessWPAPassPhrase_oid[] =
        { 1, 3, 6, 1, 4, 1, 171, 1, 2, 2, 5 };
    static oid      dlkWirelessWEPKeyOne_oid[] =
        { 1, 3, 6, 1, 4, 1, 171, 1, 2, 2, 6, 1 };
    static oid      dlkWirelessWEPKeyTwo_oid[] =
        { 1, 3, 6, 1, 4, 1, 171, 1, 2, 2, 6, 2 };
    static oid      dlkWirelessWEPKeyThree_oid[] =
        { 1, 3, 6, 1, 4, 1, 171, 1, 2, 2, 6, 3 };
    static oid      dlkWirelessWEPKeyFour_oid[] =
        { 1, 3, 6, 1, 4, 1, 171, 1, 2, 2, 6, 4 };
	/*WPA Enterprise*/
    static oid      dlkWirelessEAPType_oid[] =
        { 1, 3, 6, 1, 4, 1, 171, 1, 2, 2, 7, 1 };
    static oid      dlkWirelessAuthType_oid[] =
        { 1, 3, 6, 1, 4, 1, 171, 1, 2, 2, 7, 2 };
    static oid      dlkWirelessCertificate_oid[] =
        { 1, 3, 6, 1, 4, 1, 171, 1, 2, 2, 7, 3 };
	/*WAN*/
    static oid      dlkEnterpriseWANMode_oid[] =
        { 1, 3, 6, 1, 4, 1, 171, 1, 3, 1 };
    static oid      dlkEnterpriseWANHostName_oid[] =
        { 1, 3, 6, 1, 4, 1, 171, 1, 3, 2 };
    static oid      dlkEnterpriseWANMacAddress_oid[] =
        { 1, 3, 6, 1, 4, 1, 171, 1, 3, 3 };
    static oid      dlkEnterpriseWANCloneMac_oid[] =
        { 1, 3, 6, 1, 4, 1, 171, 1, 3, 4 };
    static oid      dlkEnterpriseWANPrimaryDNS_oid[] =
        { 1, 3, 6, 1, 4, 1, 171, 1, 3, 5 };
    static oid      dlkEnterpriseWANSecondaryDNS_oid[] =
        { 1, 3, 6, 1, 4, 1, 171, 1, 3, 6 };
    static oid      dlkEnterpriseWANMTU_oid[] =
        { 1, 3, 6, 1, 4, 1, 171, 1, 3, 7 };
    static oid      dlkEnterpriseWANIPAddress_oid[] =
        { 1, 3, 6, 1, 4, 1, 171, 1, 3, 8 };
    static oid      dlkEnterpriseWANSubnetMask_oid[] =
        { 1, 3, 6, 1, 4, 1, 171, 1, 3, 9 };
    static oid      dlkEnterpriseWANISPGateway_oid[] =
        { 1, 3, 6, 1, 4, 1, 171, 1, 3, 10 };
	/*WAN*/
	/*Packets status*/
    static oid      dlkWANTxFrameCount_oid[] =
        { 1, 3, 6, 1, 4, 1, 171, 1, 3, 11, 1, 1 };
    static oid      dlkWANTxMulticastFrameCount_oid[] =
        { 1, 3, 6, 1, 4, 1, 171, 1, 3, 11, 1, 2 };
    static oid      dlkWANTxErrorFrameCount_oid[] =
        { 1, 3, 6, 1, 4, 1, 171, 1, 3, 11, 1, 3 };
    static oid      dlkWANRxFrameCount_oid[] =
        { 1, 3, 6, 1, 4, 1, 171, 1, 3, 11, 2, 1 };
    static oid      dlkWANRxMulticastFrameCount_oid[] =
        { 1, 3, 6, 1, 4, 1, 171, 1, 3, 11, 2, 2 };
    static oid      dlkWANRxErrorFrameCount_oid[] =
        { 1, 3, 6, 1, 4, 1, 171, 1, 3, 11, 2, 3 };
	/*LAN*/
	/*LAN INFO*/
    static oid      dlkEnterpriseLANIPAddress_oid[] =
        { 1, 3, 6, 1, 4, 1, 171, 1, 4, 1, 1 };
    static oid      dlkEnterpriseLANSubnetMask_oid[] =
        { 1, 3, 6, 1, 4, 1, 171, 1, 4, 1, 2 };
    static oid      dlkEnterpriseLANDomainName_oid[] =
        { 1, 3, 6, 1, 4, 1, 171, 1, 4, 1, 3 };
    static oid      dlkEnterpriseLANDNSRelay_oid[] =
        { 1, 3, 6, 1, 4, 1, 171, 1, 4, 1, 4 };
	/*LAN*/
        /*LAN DHCP*/
    static oid      dlkEnterpriseDHCPService_oid[] =
        { 1, 3, 6, 1, 4, 1, 171, 1, 4, 2, 1 };
    static oid      dlkEnterpriseDHCPStartIP_oid[] =
        { 1, 3, 6, 1, 4, 1, 171, 1, 4, 2, 2 };
    static oid      dlkEnterpriseDHCPEndIP_oid[] =
        { 1, 3, 6, 1, 4, 1, 171, 1, 4, 2, 3 };
    static oid      dlkEnterpriseDHCPLeaseTime_oid[] =
        { 1, 3, 6, 1, 4, 1, 171, 1, 4, 2, 4 };
    static oid      dlkEnterpriseDHCPDomainName_oid[] =
        { 1, 3, 6, 1, 4, 1, 171, 1, 4, 2, 5 };
    static oid      dlkEnterpriseDHCPDNSRelay_oid[] =
        { 1, 3, 6, 1, 4, 1, 171, 1, 4, 2, 6 };
	/*LAN*/
	/*Packets status*/
    static oid      dlkLANTxFrameCount_oid[] =
        { 1, 3, 6, 1, 4, 1, 171, 1, 4, 3, 1, 1 };
    static oid      dlkLANTxMulticastFrameCount_oid[] =
        { 1, 3, 6, 1, 4, 1, 171, 1, 4, 3, 1, 2 };
    static oid      dlkLANTxErrorFrameCount_oid[] =
        { 1, 3, 6, 1, 4, 1, 171, 1, 4, 3, 1, 3 };
    static oid      dlkLANRxFrameCount_oid[] =
        { 1, 3, 6, 1, 4, 1, 171, 1, 4, 3, 2, 1 };
    static oid      dlkLANRxMulticastFrameCount_oid[] =
        { 1, 3, 6, 1, 4, 1, 171, 1, 4, 3, 2, 2 };
    static oid      dlkLANRxErrorFrameCount_oid[] =
        { 1, 3, 6, 1, 4, 1, 171, 1, 4, 3, 2, 3 };
	/*Advanced*/
	/*Advanced network */
    static oid      enterpriseUPNP_oid[] =
        { 1, 3, 6, 1, 4, 1, 171, 1, 5, 1, 1 };
    static oid      enterpriseWANPingRespond_oid[] =
        { 1, 3, 6, 1, 4, 1, 171, 1, 5, 1, 2 };
    static oid      enterpriseMulticastStreams_oid[] =
        { 1, 3, 6, 1, 4, 1, 171, 1, 5, 1, 3 };
    	/*DDNS*/
    static oid      enterpriseDDNS_oid[] =
        { 1, 3, 6, 1, 4, 1, 171, 1, 5, 2, 1 };
    static oid      enterpriseServerAddress_oid[] =
        { 1, 3, 6, 1, 4, 1, 171, 1, 5, 2, 2 };
    static oid      enterpriseHostName_oid[] =
        { 1, 3, 6, 1, 4, 1, 171, 1, 5, 2, 3 };
    static oid      enterpriseUserName_oid[] =
        { 1, 3, 6, 1, 4, 1, 171, 1, 5, 2, 4 };
    static oid      enterprisePassword_oid[] =
        { 1, 3, 6, 1, 4, 1, 171, 1, 5, 2, 5 };
	/*Firewall setting*/
    static oid      enterprisePPTPPassThrough_oid[] =
        { 1, 3, 6, 1, 4, 1, 171, 1, 5, 3, 1 };
    static oid      enterpriseL2TPPassThrough_oid[] =
        { 1, 3, 6, 1, 4, 1, 171, 1, 5, 3, 2 };
    static oid      enterpriseIPSECPassThrough_oid[] =
        { 1, 3, 6, 1, 4, 1, 171, 1, 5, 3, 3 };
	/*Mac filter type*/
    static oid      macFilterType_oid[] =
        { 1, 3, 6, 1, 4, 1, 171, 1, 5, 6, 1 };	
    	/*Web filter type*/
    static oid      webFilterType_oid[] =
        { 1, 3, 6, 1, 4, 1, 171, 1, 5, 7, 1 };
    DEBUGMSGTL(("dlink", "Initializing\n"));

    netsnmp_register_scalar(netsnmp_create_handler_registration
                            ("enterpriseModelName",
                             handle_enterpriseModelName,
                             enterpriseModelName_oid,
                             OID_LENGTH(enterpriseModelName_oid),
                             HANDLER_CAN_RONLY));
    netsnmp_register_scalar(netsnmp_create_handler_registration
                            ("enterpriseSystemTime",
                             handle_enterpriseSystemTime,
                             enterpriseSystemTime_oid,
                             OID_LENGTH(enterpriseSystemTime_oid),
                             HANDLER_CAN_RONLY));
    netsnmp_register_scalar(netsnmp_create_handler_registration
                            ("enterpriseUpTime", handle_enterpriseUpTime,
                             enterpriseUpTime_oid,
                             OID_LENGTH(enterpriseUpTime_oid),
                             HANDLER_CAN_RONLY));
    netsnmp_register_scalar(netsnmp_create_handler_registration
                            ("enterpriseFirmwareVersion",
                             handle_enterpriseFirmwareVersion,
                             enterpriseFirmwareVersion_oid,
                             OID_LENGTH(enterpriseFirmwareVersion_oid),
                             HANDLER_CAN_RONLY));
    netsnmp_register_scalar(netsnmp_create_handler_registration
                            ("enterpriseHWID", handle_enterpriseHWID,
                             enterpriseHWID_oid,
                             OID_LENGTH(enterpriseHWID_oid),
                             HANDLER_CAN_RONLY));
    netsnmp_register_scalar(netsnmp_create_handler_registration
                            ("enterpriseSystemReboot",
                             handle_enterpriseSystemReboot,
                             enterpriseSystemReboot_oid,
                             OID_LENGTH(enterpriseSystemReboot_oid),
                             HANDLER_CAN_RWRITE));
    netsnmp_register_scalar(netsnmp_create_handler_registration
                            ("enterpriseLimitAdmin",
                             handle_enterpriseLimitAdmin,
                             enterpriseLimitAdmin_oid,
                             OID_LENGTH(enterpriseLimitAdmin_oid),
                             HANDLER_CAN_RWRITE));
    netsnmp_register_scalar(netsnmp_create_handler_registration
                            ("enterpriseLimitAdminIP1",
                             handle_enterpriseLimitAdminIP1,
                             enterpriseLimitAdminIP1_oid,
                             OID_LENGTH(enterpriseLimitAdminIP1_oid),
                             HANDLER_CAN_RWRITE));
    netsnmp_register_scalar(netsnmp_create_handler_registration
                            ("enterpriseLimitAdminIP2",
                             handle_enterpriseLimitAdminIP2,
                             enterpriseLimitAdminIP2_oid,
                             OID_LENGTH(enterpriseLimitAdminIP2_oid),
                             HANDLER_CAN_RWRITE));
    netsnmp_register_scalar(netsnmp_create_handler_registration
                            ("enterpriseConsoleSettings",
                             handle_enterpriseConsoleSettings,
                             enterpriseConsoleSettings_oid,
                             OID_LENGTH(enterpriseConsoleSettings_oid),
                             HANDLER_CAN_RWRITE));
    netsnmp_register_scalar(netsnmp_create_handler_registration
                            ("enterpriseConsoleSettingsTimeout",
                             handle_enterpriseConsoleSettingsTimeout,
                             enterpriseConsoleSettingsTimeout_oid,
                             OID_LENGTH
                             (enterpriseConsoleSettingsTimeout_oid),
                             HANDLER_CAN_RWRITE));
    netsnmp_register_scalar(netsnmp_create_handler_registration
                            ("enterpriseSystemRestore",
                             handle_enterpriseSystemRestore,
                             enterpriseSystemRestore_oid,
                             OID_LENGTH(enterpriseSystemRestore_oid),
                             HANDLER_CAN_RWRITE));
    netsnmp_register_scalar(netsnmp_create_handler_registration
                            ("enterpriseSSID", handle_enterpriseSSID,
                             enterpriseSSID_oid,
                             OID_LENGTH(enterpriseSSID_oid),
                             HANDLER_CAN_RWRITE));
    netsnmp_register_scalar(netsnmp_create_handler_registration
                            ("enterpriseChannel", handle_enterpriseChannel,
                             enterpriseChannel_oid,
                             OID_LENGTH(enterpriseChannel_oid),
                             HANDLER_CAN_RWRITE));
    netsnmp_register_scalar(netsnmp_create_handler_registration
                            ("enterpriseDataRate",
                             handle_enterpriseDataRate,
                             enterpriseDataRate_oid,
                             OID_LENGTH(enterpriseDataRate_oid),
                             HANDLER_CAN_RWRITE));
    netsnmp_register_scalar(netsnmp_create_handler_registration
                            ("enterpriseFragmentLength",
                             handle_enterpriseFragmentLength,
                             enterpriseFragmentLength_oid,
                             OID_LENGTH(enterpriseFragmentLength_oid),
                             HANDLER_CAN_RWRITE));
    netsnmp_register_scalar(netsnmp_create_handler_registration
                            ("enterpriseRTSLength",
                             handle_enterpriseRTSLength,
                             enterpriseRTSLength_oid,
                             OID_LENGTH(enterpriseRTSLength_oid),
                             HANDLER_CAN_RWRITE));
    netsnmp_register_scalar(netsnmp_create_handler_registration
                            ("enterpriseTransmitPower",
                             handle_enterpriseTransmitPower,
                             enterpriseTransmitPower_oid,
                             OID_LENGTH(enterpriseTransmitPower_oid),
                             HANDLER_CAN_RWRITE));
    netsnmp_register_scalar(netsnmp_create_handler_registration
                            ("enterpriseBGMode", handle_enterpriseBGMode,
                             enterpriseBGMode_oid,
                             OID_LENGTH(enterpriseBGMode_oid),
                             HANDLER_CAN_RWRITE));
    netsnmp_register_scalar(netsnmp_create_handler_registration
                            ("enterpriseAntennaDiversity",
                             handle_enterpriseAntennaDiversity,
                             enterpriseAntennaDiversity_oid,
                             OID_LENGTH(enterpriseAntennaDiversity_oid),
                             HANDLER_CAN_RWRITE));
    netsnmp_register_scalar(netsnmp_create_handler_registration
                            ("enterpriseConnectedTime",
                             handle_enterpriseConnectedTime,
                             enterpriseConnectedTime_oid,
                             OID_LENGTH(enterpriseConnectedTime_oid),
                             HANDLER_CAN_RONLY));
    netsnmp_register_scalar(netsnmp_create_handler_registration
                            ("dlkWirelessAuthenticationType",
                             handle_dlkWirelessAuthenticationType,
                             dlkWirelessAuthenticationType_oid,
                             OID_LENGTH(dlkWirelessAuthenticationType_oid),
                             HANDLER_CAN_RWRITE));
    netsnmp_register_scalar(netsnmp_create_handler_registration
                            ("dlkWirelessWEPKeyType",
                             handle_dlkWirelessWEPKeyType,
                             dlkWirelessWEPKeyType_oid,
                             OID_LENGTH(dlkWirelessWEPKeyType_oid),
                             HANDLER_CAN_RWRITE)); 
    netsnmp_register_scalar(netsnmp_create_handler_registration
                            ("dlkWirelessWEPKeySize",
                             handle_dlkWirelessWEPKeySize,
                             dlkWirelessWEPKeySize_oid,
                             OID_LENGTH(dlkWirelessWEPKeySize_oid),
                             HANDLER_CAN_RWRITE));
    netsnmp_register_scalar(netsnmp_create_handler_registration
                            ("dlkWirelessWEPValidKey",
                             handle_dlkWirelessWEPValidKey,
                             dlkWirelessWEPValidKey_oid,
                             OID_LENGTH(dlkWirelessWEPValidKey_oid),
                             HANDLER_CAN_RWRITE));
    netsnmp_register_scalar(netsnmp_create_handler_registration
                            ("dlkWirelessWPAPassPhrase",
                             handle_dlkWirelessWPAPassPhrase,
                             dlkWirelessWPAPassPhrase_oid,
                             OID_LENGTH(dlkWirelessWPAPassPhrase_oid),
                             HANDLER_CAN_RWRITE));
    netsnmp_register_scalar(netsnmp_create_handler_registration
                            ("dlkWirelessWEPKeyOne",
                             handle_dlkWirelessWEPKeyOne,
                             dlkWirelessWEPKeyOne_oid,
                             OID_LENGTH(dlkWirelessWEPKeyOne_oid),
                             HANDLER_CAN_RWRITE));
    netsnmp_register_scalar(netsnmp_create_handler_registration
                            ("dlkWirelessWEPKeyTwo",
                             handle_dlkWirelessWEPKeyTwo,
                             dlkWirelessWEPKeyTwo_oid,
                             OID_LENGTH(dlkWirelessWEPKeyTwo_oid),
                             HANDLER_CAN_RWRITE));
    netsnmp_register_scalar(netsnmp_create_handler_registration
                            ("dlkWirelessWEPKeyThree",
                             handle_dlkWirelessWEPKeyThree,
                             dlkWirelessWEPKeyThree_oid,
                             OID_LENGTH(dlkWirelessWEPKeyThree_oid),
                             HANDLER_CAN_RWRITE));
    netsnmp_register_scalar(netsnmp_create_handler_registration
                            ("dlkWirelessWEPKeyFour",
                             handle_dlkWirelessWEPKeyFour,
                             dlkWirelessWEPKeyFour_oid,
                             OID_LENGTH(dlkWirelessWEPKeyFour_oid),
                             HANDLER_CAN_RWRITE));
    netsnmp_register_scalar(netsnmp_create_handler_registration
                            ("dlkWirelessEAPType",
                             handle_dlkWirelessEAPType,
                             dlkWirelessEAPType_oid,
                             OID_LENGTH(dlkWirelessEAPType_oid),
                             HANDLER_CAN_RWRITE));   
    netsnmp_register_scalar(netsnmp_create_handler_registration
                            ("dlkWirelessAuthType",
                             handle_dlkWirelessAuthType,
                             dlkWirelessAuthType_oid,
                             OID_LENGTH(dlkWirelessAuthType_oid),
                             HANDLER_CAN_RWRITE));
    netsnmp_register_scalar(netsnmp_create_handler_registration
                            ("dlkWirelessCertificate",
                             handle_dlkWirelessCertificate,
                             dlkWirelessCertificate_oid,
                             OID_LENGTH(dlkWirelessCertificate_oid),
                             HANDLER_CAN_RWRITE));
    netsnmp_register_scalar(netsnmp_create_handler_registration
                            ("dlkEnterpriseWANMode",
                             handle_dlkEnterpriseWANMode,
                             dlkEnterpriseWANMode_oid,
                             OID_LENGTH(dlkEnterpriseWANMode_oid),
                             HANDLER_CAN_RWRITE));
    netsnmp_register_scalar(netsnmp_create_handler_registration
                            ("dlkEnterpriseWANHostName",
                             handle_dlkEnterpriseWANHostName,
                             dlkEnterpriseWANHostName_oid,
                             OID_LENGTH(dlkEnterpriseWANHostName_oid),
                             HANDLER_CAN_RWRITE));
    netsnmp_register_scalar(netsnmp_create_handler_registration
                            ("dlkEnterpriseWANMacAddress",
                             handle_dlkEnterpriseWANMacAddress,
                             dlkEnterpriseWANMacAddress_oid,
                             OID_LENGTH(dlkEnterpriseWANMacAddress_oid),
                             HANDLER_CAN_RWRITE));
     netsnmp_register_scalar(netsnmp_create_handler_registration
                            ("dlkEnterpriseWANCloneMac",
                             handle_dlkEnterpriseWANCloneMac,
                             dlkEnterpriseWANCloneMac_oid,
                             OID_LENGTH(dlkEnterpriseWANCloneMac_oid),
                             HANDLER_CAN_RWRITE));
    netsnmp_register_scalar(netsnmp_create_handler_registration
                            ("dlkEnterpriseWANPrimaryDNS",
                             handle_dlkEnterpriseWANPrimaryDNS,
                             dlkEnterpriseWANPrimaryDNS_oid,
                             OID_LENGTH(dlkEnterpriseWANPrimaryDNS_oid),
                             HANDLER_CAN_RWRITE));
    netsnmp_register_scalar(netsnmp_create_handler_registration
                            ("dlkEnterpriseWANSecondaryDNS",
                             handle_dlkEnterpriseWANSecondaryDNS,
                             dlkEnterpriseWANSecondaryDNS_oid,
                             OID_LENGTH(dlkEnterpriseWANSecondaryDNS_oid),
                             HANDLER_CAN_RWRITE));
    netsnmp_register_scalar(netsnmp_create_handler_registration
                            ("dlkEnterpriseWANMTU",
                             handle_dlkEnterpriseWANMTU,
                             dlkEnterpriseWANMTU_oid,
                             OID_LENGTH(dlkEnterpriseWANMTU_oid),
                             HANDLER_CAN_RWRITE));
    netsnmp_register_scalar(netsnmp_create_handler_registration
                            ("dlkEnterpriseWANIPAddress",
                             handle_dlkEnterpriseWANIPAddress,
                             dlkEnterpriseWANIPAddress_oid,
                             OID_LENGTH(dlkEnterpriseWANIPAddress_oid),
                             HANDLER_CAN_RWRITE));
    netsnmp_register_scalar(netsnmp_create_handler_registration
                            ("dlkEnterpriseWANSubnetMask",
                             handle_dlkEnterpriseWANSubnetMask,
                             dlkEnterpriseWANSubnetMask_oid,
                             OID_LENGTH(dlkEnterpriseWANSubnetMask_oid),
                             HANDLER_CAN_RWRITE));
    netsnmp_register_scalar(netsnmp_create_handler_registration
                            ("dlkEnterpriseWANISPGateway",
                             handle_dlkEnterpriseWANISPGateway,
                             dlkEnterpriseWANISPGateway_oid,
                             OID_LENGTH(dlkEnterpriseWANISPGateway_oid),
                             HANDLER_CAN_RWRITE));
    netsnmp_register_scalar(netsnmp_create_handler_registration
                            ("enterpriseUPNP", handle_enterpriseUPNP,
                             enterpriseUPNP_oid,
                             OID_LENGTH(enterpriseUPNP_oid),
                             HANDLER_CAN_RWRITE));
    netsnmp_register_scalar(netsnmp_create_handler_registration
                            ("enterpriseWANPingRespond",
                             handle_enterpriseWANPingRespond,
                             enterpriseWANPingRespond_oid,
                             OID_LENGTH(enterpriseWANPingRespond_oid),
                             HANDLER_CAN_RWRITE));
    netsnmp_register_scalar(netsnmp_create_handler_registration
                            ("enterpriseMulticastStreams",
                             handle_enterpriseMulticastStreams,
                             enterpriseMulticastStreams_oid,
                             OID_LENGTH(enterpriseMulticastStreams_oid),
                             HANDLER_CAN_RWRITE));
    netsnmp_register_scalar(netsnmp_create_handler_registration
                            ("enterpriseDDNS", handle_enterpriseDDNS,
                             enterpriseDDNS_oid,
                             OID_LENGTH(enterpriseDDNS_oid),
                             HANDLER_CAN_RWRITE));
    netsnmp_register_scalar(netsnmp_create_handler_registration
                            ("enterpriseServerAddress",
                             handle_enterpriseServerAddress,
                             enterpriseServerAddress_oid,
                             OID_LENGTH(enterpriseServerAddress_oid),
                             HANDLER_CAN_RWRITE));
    netsnmp_register_scalar(netsnmp_create_handler_registration
                            ("enterpriseHostName",
                             handle_enterpriseHostName,
                             enterpriseHostName_oid,
                             OID_LENGTH(enterpriseHostName_oid),
                             HANDLER_CAN_RWRITE));
    netsnmp_register_scalar(netsnmp_create_handler_registration
                            ("enterpriseUserName",
                             handle_enterpriseUserName,
                             enterpriseUserName_oid,
                             OID_LENGTH(enterpriseUserName_oid),
                             HANDLER_CAN_RWRITE));
    netsnmp_register_scalar(netsnmp_create_handler_registration
                            ("enterprisePassword",
                             handle_enterprisePassword,
                             enterprisePassword_oid,
                             OID_LENGTH(enterprisePassword_oid),
                             HANDLER_CAN_RWRITE));
    netsnmp_register_scalar(netsnmp_create_handler_registration
                            ("enterprisePPTPPassThrough",
                             handle_enterprisePPTPPassThrough,
                             enterprisePPTPPassThrough_oid,
                             OID_LENGTH(enterprisePPTPPassThrough_oid),
                             HANDLER_CAN_RWRITE));
    netsnmp_register_scalar(netsnmp_create_handler_registration
                            ("enterpriseL2TPPassThrough",
                             handle_enterpriseL2TPPassThrough,
                             enterpriseL2TPPassThrough_oid,
                             OID_LENGTH(enterpriseL2TPPassThrough_oid),
                             HANDLER_CAN_RWRITE));
    netsnmp_register_scalar(netsnmp_create_handler_registration
                            ("enterpriseIPSECPassThrough",
                             handle_enterpriseIPSECPassThrough,
                             enterpriseIPSECPassThrough_oid,
                             OID_LENGTH(enterpriseIPSECPassThrough_oid),
                             HANDLER_CAN_RWRITE));
    netsnmp_register_scalar(netsnmp_create_handler_registration
                            ("dlkEnterpriseLANIPAddress",
                             handle_dlkEnterpriseLANIPAddress,
                             dlkEnterpriseLANIPAddress_oid,
                             OID_LENGTH(dlkEnterpriseLANIPAddress_oid),
                             HANDLER_CAN_RWRITE));
    netsnmp_register_scalar(netsnmp_create_handler_registration
                            ("dlkEnterpriseLANSubnetMask",
                             handle_dlkEnterpriseLANSubnetMask,
                             dlkEnterpriseLANSubnetMask_oid,
                             OID_LENGTH(dlkEnterpriseLANSubnetMask_oid),
                             HANDLER_CAN_RWRITE));
    netsnmp_register_scalar(netsnmp_create_handler_registration
                            ("dlkEnterpriseLANDomainName",
                             handle_dlkEnterpriseLANDomainName,
                             dlkEnterpriseLANDomainName_oid,
                             OID_LENGTH(dlkEnterpriseLANDomainName_oid),
                             HANDLER_CAN_RWRITE));
    netsnmp_register_scalar(netsnmp_create_handler_registration
                            ("dlkEnterpriseLANDNSRelay",
                             handle_dlkEnterpriseLANDNSRelay,
                             dlkEnterpriseLANDNSRelay_oid,
                             OID_LENGTH(dlkEnterpriseLANDNSRelay_oid),
                             HANDLER_CAN_RWRITE));
    netsnmp_register_scalar(netsnmp_create_handler_registration
                            ("dlkWANTxErrorFrameCount",
                             handle_dlkWANTxErrorFrameCount,
                             dlkWANTxErrorFrameCount_oid,
                             OID_LENGTH(dlkWANTxErrorFrameCount_oid),
                             HANDLER_CAN_RONLY));
    netsnmp_register_scalar(netsnmp_create_handler_registration
                            ("dlkWANTxMulticastFrameCount",
                             handle_dlkWANTxMulticastFrameCount,
                             dlkWANTxMulticastFrameCount_oid,
                             OID_LENGTH(dlkWANTxMulticastFrameCount_oid),
                             HANDLER_CAN_RONLY));
    netsnmp_register_scalar(netsnmp_create_handler_registration
                            ("dlkWANTxFrameCount", handle_dlkWANTxFrameCount,
                             dlkWANTxFrameCount_oid,
                             OID_LENGTH(dlkWANTxFrameCount_oid),
                             HANDLER_CAN_RONLY));
    netsnmp_register_scalar(netsnmp_create_handler_registration
                            ("dlkWANRxErrorFrameCount",
                             handle_dlkWANRxErrorFrameCount,
                             dlkWANRxErrorFrameCount_oid,
                             OID_LENGTH(dlkWANRxErrorFrameCount_oid),
                             HANDLER_CAN_RONLY));
    netsnmp_register_scalar(netsnmp_create_handler_registration
                            ("dlkWANRxMulticastFrameCount",
                             handle_dlkWANRxMulticastFrameCount,
                             dlkWANRxMulticastFrameCount_oid,
                             OID_LENGTH(dlkWANRxMulticastFrameCount_oid),
                             HANDLER_CAN_RONLY));
    netsnmp_register_scalar(netsnmp_create_handler_registration
                            ("dlkWANRxFrameCount", handle_dlkWANRxFrameCount,
                             dlkWANRxFrameCount_oid,
                             OID_LENGTH(dlkWANRxFrameCount_oid),
                             HANDLER_CAN_RONLY));
    netsnmp_register_scalar(netsnmp_create_handler_registration
                            ("dlkLANTxFrameCount",
                             handle_dlkLANTxFrameCount,
                             dlkLANTxFrameCount_oid,
                             OID_LENGTH(dlkLANTxFrameCount_oid),
                             HANDLER_CAN_RONLY));
    netsnmp_register_scalar(netsnmp_create_handler_registration
                            ("dlkLANTxMulticastFrameCount",
                             handle_dlkLANTxMulticastFrameCount,
                             dlkLANTxMulticastFrameCount_oid,
                             OID_LENGTH(dlkLANTxMulticastFrameCount_oid),
                             HANDLER_CAN_RONLY));
    netsnmp_register_scalar(netsnmp_create_handler_registration
                            ("dlkLANTxErrorFrameCount",
                             handle_dlkLANTxErrorFrameCount,
                             dlkLANTxErrorFrameCount_oid,
                             OID_LENGTH(dlkLANTxErrorFrameCount_oid),
                             HANDLER_CAN_RONLY));
    netsnmp_register_scalar(netsnmp_create_handler_registration
                            ("dlkLANRxMulticastFrameCount",
                             handle_dlkLANRxMulticastFrameCount,
                             dlkLANRxMulticastFrameCount_oid,
                             OID_LENGTH(dlkLANRxMulticastFrameCount_oid),
                             HANDLER_CAN_RONLY));
    netsnmp_register_scalar(netsnmp_create_handler_registration
                            ("dlkLANRxFrameCount",
                             handle_dlkLANRxFrameCount,
                             dlkLANRxFrameCount_oid,
                             OID_LENGTH(dlkLANRxFrameCount_oid),
                             HANDLER_CAN_RONLY));
    netsnmp_register_scalar(netsnmp_create_handler_registration
                            ("dlkLANRxErrorFrameCount",
                             handle_dlkLANRxErrorFrameCount,
                             dlkLANRxErrorFrameCount_oid,
                             OID_LENGTH(dlkLANRxErrorFrameCount_oid),
                             HANDLER_CAN_RONLY));
    netsnmp_register_scalar(netsnmp_create_handler_registration
                            ("dlkEnterpriseDHCPService",
                             handle_dlkEnterpriseDHCPService,
                             dlkEnterpriseDHCPService_oid,
                             OID_LENGTH(dlkEnterpriseDHCPService_oid),
                             HANDLER_CAN_RWRITE));
    netsnmp_register_scalar(netsnmp_create_handler_registration
                            ("dlkEnterpriseDHCPDNSRelay",
                             handle_dlkEnterpriseDHCPDNSRelay,
                             dlkEnterpriseDHCPDNSRelay_oid,
                             OID_LENGTH(dlkEnterpriseDHCPDNSRelay_oid),
                             HANDLER_CAN_RWRITE));
    netsnmp_register_scalar(netsnmp_create_handler_registration
                            ("dlkEnterpriseDHCPDomainName",
                             handle_dlkEnterpriseDHCPDomainName,
                             dlkEnterpriseDHCPDomainName_oid,
                             OID_LENGTH(dlkEnterpriseDHCPDomainName_oid),
                             HANDLER_CAN_RWRITE));
    netsnmp_register_scalar(netsnmp_create_handler_registration
                            ("dlkEnterpriseDHCPEndIP",
                             handle_dlkEnterpriseDHCPEndIP,
                             dlkEnterpriseDHCPEndIP_oid,
                             OID_LENGTH(dlkEnterpriseDHCPEndIP_oid),
                             HANDLER_CAN_RWRITE));
    netsnmp_register_scalar(netsnmp_create_handler_registration
                            ("dlkEnterpriseDHCPStartIP",
                             handle_dlkEnterpriseDHCPStartIP,
                             dlkEnterpriseDHCPStartIP_oid,
                             OID_LENGTH(dlkEnterpriseDHCPStartIP_oid),
                             HANDLER_CAN_RWRITE));
    netsnmp_register_scalar(netsnmp_create_handler_registration
                            ("dlkEnterpriseDHCPLeaseTime",
                             handle_dlkEnterpriseDHCPLeaseTime,
                             dlkEnterpriseDHCPLeaseTime_oid,
                             OID_LENGTH(dlkEnterpriseDHCPLeaseTime_oid),
                             HANDLER_CAN_RWRITE));
    netsnmp_register_scalar(netsnmp_create_handler_registration
                            ("enterpriseNTPServerIP",
                             handle_enterpriseNTPServerIP,
                             enterpriseNTPServerIP_oid,
                             OID_LENGTH(enterpriseNTPServerIP_oid),
                             HANDLER_CAN_RWRITE));
    netsnmp_register_scalar(netsnmp_create_handler_registration
                            ("enterpriseNTPTimeZone",
                             handle_enterpriseNTPTimeZone,
                             enterpriseNTPTimeZone_oid,
                             OID_LENGTH(enterpriseNTPTimeZone_oid),
                             HANDLER_CAN_RWRITE));
    netsnmp_register_scalar(netsnmp_create_handler_registration
                            ("EnterpriseNTPDaylightSaving",
                             handle_EnterpriseNTPDaylightSaving,
                             EnterpriseNTPDaylightSaving_oid,
                             OID_LENGTH(EnterpriseNTPDaylightSaving_oid),
                             HANDLER_CAN_RWRITE));
    netsnmp_register_scalar(netsnmp_create_handler_registration
                            ("enterpriseStartWeek",
                             handle_enterpriseStartWeek,
                             enterpriseStartWeek_oid,
                             OID_LENGTH(enterpriseStartWeek_oid),
                             HANDLER_CAN_RWRITE));
    netsnmp_register_scalar(netsnmp_create_handler_registration
                            ("enterpriseStartTime",
                             handle_enterpriseStartTime,
                             enterpriseStartTime_oid,
                             OID_LENGTH(enterpriseStartTime_oid),
                             HANDLER_CAN_RWRITE));
    netsnmp_register_scalar(netsnmp_create_handler_registration
                            ("enterpriseStartDayOfWeek",
                             handle_enterpriseStartDayOfWeek,
                             enterpriseStartDayOfWeek_oid,
                             OID_LENGTH(enterpriseStartDayOfWeek_oid),
                             HANDLER_CAN_RWRITE));
    netsnmp_register_scalar(netsnmp_create_handler_registration
                            ("enterpriseStartMonth",
                             handle_enterpriseStartMonth,
                             enterpriseStartMonth_oid,
                             OID_LENGTH(enterpriseStartMonth_oid),
                             HANDLER_CAN_RWRITE));
    netsnmp_register_scalar(netsnmp_create_handler_registration
                            ("enterpriseEndWeek",
                             handle_enterpriseEndWeek,
                             enterpriseEndWeek_oid,
                             OID_LENGTH(enterpriseEndWeek_oid),
                             HANDLER_CAN_RWRITE));
    netsnmp_register_scalar(netsnmp_create_handler_registration
                            ("enterpriseEndTime",
                             handle_enterpriseEndTime,
                             enterpriseEndTime_oid,
                             OID_LENGTH(enterpriseEndTime_oid),
                             HANDLER_CAN_RWRITE));
    netsnmp_register_scalar(netsnmp_create_handler_registration
                            ("enterpriseEndDayOfWeek",
                             handle_enterpriseEndDayOfWeek,
                             enterpriseEndDayOfWeek_oid,
                             OID_LENGTH(enterpriseEndDayOfWeek_oid),
                             HANDLER_CAN_RWRITE));
    netsnmp_register_scalar(netsnmp_create_handler_registration
                            ("enterpriseEndMonth",
                             handle_enterpriseEndMonth,
                             enterpriseEndMonth_oid,
                             OID_LENGTH(enterpriseEndMonth_oid),
                             HANDLER_CAN_RWRITE));
    netsnmp_register_scalar(netsnmp_create_handler_registration
                            ("macFilterType", handle_macFilterType,
                             macFilterType_oid,
                             OID_LENGTH(macFilterType_oid),
                             HANDLER_CAN_RWRITE));
    netsnmp_register_scalar(netsnmp_create_handler_registration
                            ("webFilterType", handle_webFilterType,
                             webFilterType_oid,
                             OID_LENGTH(webFilterType_oid),
                             HANDLER_CAN_RWRITE));
}
/***************************************************
*	for dlkEnterpriseCommonInfo leaf node
****************************************************/
int
handle_enterpriseModelName(netsnmp_mib_handler *handler,
                           netsnmp_handler_registration *reginfo,
                           netsnmp_agent_request_info *reqinfo,
                           netsnmp_request_info *requests)
{
    switch (reqinfo->mode) {

    case MODE_GET:
        snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,
                                 (u_char *)SYSTEMMODELNAME,strlen(SYSTEMMODELNAME));
        break;
    default:
        return SNMP_ERR_NOACCESS;
    }
    return SNMP_ERR_NOERROR;
}

int
handle_enterpriseSystemTime(netsnmp_mib_handler *handler,
                            netsnmp_handler_registration *reginfo,
                            netsnmp_agent_request_info *reqinfo,
                            netsnmp_request_info *requests)
{
    switch (reqinfo->mode) {
    case MODE_GET:
        snmp_set_var_typed_value(requests->requestvb, ASN_TIMETICKS,
                                 (u_char *)&system_time,sizeof(U_INT));
        break;
    default:
        return SNMP_ERR_NOACCESS;
    }
    return SNMP_ERR_NOERROR;
}

int
handle_enterpriseUpTime(netsnmp_mib_handler *handler,
                        netsnmp_handler_registration *reginfo,
                        netsnmp_agent_request_info *reqinfo,
                        netsnmp_request_info *requests)
{
    switch (reqinfo->mode) {
    case MODE_GET:
        snmp_set_var_typed_value(requests->requestvb, ASN_TIMETICKS,
                                 (u_char *)&system_uptime,sizeof(U_INT));
        break;
    default:
        return SNMP_ERR_GENERR;
    }
    return SNMP_ERR_NOERROR;
}

int
handle_enterpriseFirmwareVersion(netsnmp_mib_handler *handler,
                                 netsnmp_handler_registration *reginfo,
                                 netsnmp_agent_request_info *reqinfo,
                                 netsnmp_request_info *requests)
{
    switch (reqinfo->mode) {
    case MODE_GET:
        snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,
                                 (u_char *)SYSTEMFIRMWAREVERSION,strlen(SYSTEMFIRMWAREVERSION));
        break;
    default:
        return SNMP_ERR_GENERR;
    }
    return SNMP_ERR_NOERROR;
}

int
handle_enterpriseHWID(netsnmp_mib_handler *handler,
                      netsnmp_handler_registration *reginfo,
                      netsnmp_agent_request_info *reqinfo,
                      netsnmp_request_info *requests)
{
    switch (reqinfo->mode) {
    case MODE_GET:
        snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,
                                 (u_char *)SYSTEMHWID,strlen(SYSTEMHWID));
        break;
    default:
        return SNMP_ERR_GENERR;
    }
    return SNMP_ERR_NOERROR;
}

int
handle_enterpriseSystemReboot(netsnmp_mib_handler *handler,
                              netsnmp_handler_registration *reginfo,
                              netsnmp_agent_request_info *reqinfo,
                              netsnmp_request_info *requests)
{
    static U_INT temp_reboot;
    int check_flag_reboot;
    switch (reqinfo->mode) {
    case MODE_GET:
        snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
                                 (u_char *)&system_reboot,sizeof(U_INT));
        break;
    case MODE_SET_RESERVE1:
	if (requests->requestvb->val_len == 0)
                return SNMP_ERR_GENERR;
	temp_reboot = *((long *)requests->requestvb->val.integer);
	if(requests->requestvb->type != ASN_INTEGER)
                netsnmp_set_request_error(reqinfo, requests,SNMP_ERR_WRONGTYPE);
	if(temp_reboot == 0 || temp_reboot == 1)
		check_flag_reboot = 0;
	else
		check_flag_reboot = 1;
	if(check_flag_reboot)
		netsnmp_set_request_error(reqinfo, requests,SNMP_ERR_WRONGVALUE);
        break;
    case MODE_SET_RESERVE2:
        break;
    case MODE_SET_FREE:
        break;
    case MODE_SET_ACTION:
	if(temp_reboot)
	{
		temp_reboot = 0;
		/*if we got broad, this will replace real "reboot" function*/
        	printf("start rebooting.........\n");
	}
	break;
    case MODE_SET_COMMIT:
        break;
    case MODE_SET_UNDO:
        	temp_reboot = 0;
	break;
    default:
        return SNMP_ERR_GENERR;
    }
    return SNMP_ERR_NOERROR;
}
                                                         

int
handle_enterpriseLimitAdmin(netsnmp_mib_handler *handler,
                            netsnmp_handler_registration *reginfo,
                            netsnmp_agent_request_info *reqinfo,
                            netsnmp_request_info *requests)
{
    static U_INT temp_admin;
    int check_flag_admin;
    switch (reqinfo->mode) {
    case MODE_GET:
        snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
                                 (u_char *)&system_admin,sizeof(U_INT));
        break;
    case MODE_SET_RESERVE1:
	if (requests->requestvb->val_len == 0)
                return SNMP_ERR_GENERR;
	temp_admin = *((long *)requests->requestvb->val.integer);
	if(requests->requestvb->type != ASN_INTEGER)
                netsnmp_set_request_error(reqinfo, requests,SNMP_ERR_WRONGTYPE);
	if(temp_admin == 0 || temp_admin == 1)
                check_flag_admin = 0;
        else
                check_flag_admin = 1;
        if(check_flag_admin)
                netsnmp_set_request_error(reqinfo, requests,SNMP_ERR_WRONGVALUE);
        break;
    case MODE_SET_RESERVE2:
        break;
    case MODE_SET_FREE:
        break;
    case MODE_SET_ACTION:
        if(temp_admin){
		/*if we got broad, this will replace real "enable admin" function*/
		printf("enable limit admin\n");
		system_admin = temp_admin;
	}
	else
		system_admin = 0;
	break;
    case MODE_SET_COMMIT:
        break;
    case MODE_SET_UNDO:
	break;
    default:
        return SNMP_ERR_GENERR;
    }
   return SNMP_ERR_NOERROR;
}

int
handle_enterpriseLimitAdminIP1(netsnmp_mib_handler *handler,
                               netsnmp_handler_registration *reginfo,
                               netsnmp_agent_request_info *reqinfo,
                               netsnmp_request_info *requests)
{
    static struct in_addr limitip1;
    static char temp_ip[] = "192.168.0.1";

    switch (reqinfo->mode) {
    case MODE_GET:
	inet_aton(temp_ip,&limitip1);
	snmp_set_var_typed_value(requests->requestvb, ASN_IPADDRESS,(u_char *)&limitip1.s_addr,sizeof(long));
        break;
    case MODE_SET_RESERVE1:
	if(requests->requestvb->type != ASN_IPADDRESS)
                netsnmp_set_request_error(reqinfo, requests,SNMP_ERR_WRONGTYPE);
	if(system_admin == 1)
		memset(&limitip1,0,sizeof(limitip1));
	else 	
		netsnmp_set_request_error(reqinfo, requests,SNMP_ERR_NOACCESS);
        break;
    case MODE_SET_RESERVE2:
 	break;
    case MODE_SET_FREE:
        break;
    case MODE_SET_ACTION:
	limitip1.s_addr = *((long *)requests->requestvb->val.string);
	if(strcmp(inet_ntoa(limitip1),"NULL") == 0)
                netsnmp_set_request_error(reqinfo, requests,SNMP_ERR_WRONGVALUE);
	if(check_illegal_ip(inet_ntoa(limitip1)) == -1)
		netsnmp_set_request_error(reqinfo, requests,SNMP_ERR_WRONGVALUE);
	else
		strcpy(temp_ip,inet_ntoa(limitip1)); 
        break;
    case MODE_SET_COMMIT:
        break;
    case MODE_SET_UNDO:
        break;
    default:
        return SNMP_ERR_GENERR;
    }
    return SNMP_ERR_NOERROR;
}

int
handle_enterpriseLimitAdminIP2(netsnmp_mib_handler *handler,
                               netsnmp_handler_registration *reginfo,
                               netsnmp_agent_request_info *reqinfo,
                               netsnmp_request_info *requests)
{
    static struct in_addr limitip2;
    static char temp_ip[] = "10.0.0.1";

    switch (reqinfo->mode) {
    case MODE_GET:
        inet_aton(temp_ip,&limitip2);
        snmp_set_var_typed_value(requests->requestvb, ASN_IPADDRESS,(u_char *)&limitip2.s_addr,sizeof(long));
	break;
    case MODE_SET_RESERVE1:
	if(requests->requestvb->type != ASN_IPADDRESS)
                netsnmp_set_request_error(reqinfo, requests,SNMP_ERR_WRONGTYPE);
	if(system_admin == 1)
                memset(&limitip2,0,sizeof(limitip2));
        else
                netsnmp_set_request_error(reqinfo, requests,SNMP_ERR_NOACCESS);

        break;
    case MODE_SET_RESERVE2:
        break;
    case MODE_SET_FREE:
        break;
    case MODE_SET_ACTION:
	limitip2.s_addr = *((long *)requests->requestvb->val.string);
        if(strcmp(inet_ntoa(limitip2),"NULL") == 0)
                netsnmp_set_request_error(reqinfo, requests,SNMP_ERR_WRONGVALUE);
	if(check_illegal_ip(inet_ntoa(limitip2)) == -1)
                netsnmp_set_request_error(reqinfo, requests,SNMP_ERR_WRONGVALUE);
        else
                strcpy(temp_ip,inet_ntoa(limitip2));

        break;
    case MODE_SET_COMMIT:
        break;
    case MODE_SET_UNDO:
        break;
    default:
        return SNMP_ERR_GENERR;
}
    return SNMP_ERR_NOERROR;
}

int
handle_enterpriseConsoleSettings(netsnmp_mib_handler *handler,
                                 netsnmp_handler_registration *reginfo,
                                 netsnmp_agent_request_info *reqinfo,
                                 netsnmp_request_info *requests)
{
    static U_INT temp_console;
    int check_flag_console;
    switch (reqinfo->mode) {
    case MODE_GET:
        snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
                                 (u_char *)&system_console,sizeof(U_INT));
        break;
    case MODE_SET_RESERVE1:
	if (requests->requestvb->val_len == 0)
                return SNMP_ERR_GENERR;
        temp_console = *((long *)requests->requestvb->val.integer);
        if(requests->requestvb->type != ASN_INTEGER)
                netsnmp_set_request_error(reqinfo, requests,SNMP_ERR_WRONGTYPE);
	if(temp_console == 0 || temp_console == 1)
                check_flag_console = 0;
        else
                check_flag_console = 1;
        if(check_flag_console)
                netsnmp_set_request_error(reqinfo, requests,SNMP_ERR_WRONGVALUE);
        break;
    case MODE_SET_RESERVE2:
        break;
    case MODE_SET_FREE:
        break;
    case MODE_SET_ACTION:
        if(temp_console){
                /*if we got broad, this will replace real "enable admin" function*/
                printf("enable console settings\n");
                system_console = temp_console;
        }
        else
                system_console = 0;
        break;
    case MODE_SET_COMMIT:
        break;
    case MODE_SET_UNDO:
        break;
    default:
        return SNMP_ERR_GENERR;
    }
    return SNMP_ERR_NOERROR;
}

int
handle_enterpriseConsoleSettingsTimeout(netsnmp_mib_handler *handler,
                                        netsnmp_handler_registration
                                        *reginfo,
                                        netsnmp_agent_request_info
                                        *reqinfo,
                                        netsnmp_request_info *requests)
{
    static U_INT temp_console_timeout;

    switch (reqinfo->mode) {
    case MODE_GET:
	snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
                                 (u_char *)&system_console_timeout,sizeof(U_INT));
        break;
    case MODE_SET_RESERVE1:
        if(system_console == 0)
                netsnmp_set_request_error(reqinfo, requests,SNMP_ERR_NOACCESS);
        break;
    case MODE_SET_RESERVE2:
        break;
    case MODE_SET_FREE:
        break;
    case MODE_SET_ACTION:
	if (requests->requestvb->val_len == 0)
                return SNMP_ERR_GENERR;
	temp_console_timeout = *((long *)requests->requestvb->val.integer);
        if(requests->requestvb->type != ASN_INTEGER)
                netsnmp_set_request_error(reqinfo, requests,SNMP_ERR_WRONGTYPE);
	if(temp_console_timeout < 0 || temp_console_timeout > 6)
		netsnmp_set_request_error(reqinfo, requests,SNMP_ERR_WRONGVALUE);
	else
        	system_console_timeout = temp_console_timeout;
	/*if we got broad, this will replace real "console timeout" function*/
	printf("execute console timeout function\n");
	break;
    case MODE_SET_COMMIT:
        break;
    case MODE_SET_UNDO:
        break;
    default:
        return SNMP_ERR_GENERR;
    }
    return SNMP_ERR_NOERROR;
}

int
handle_enterpriseSystemRestore(netsnmp_mib_handler *handler,
                               netsnmp_handler_registration *reginfo,
                               netsnmp_agent_request_info *reqinfo,
                               netsnmp_request_info *requests)
{
    static U_INT temp_restore;
    int check_flag_restore;

    switch (reqinfo->mode) {
    case MODE_GET:
        snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
                                 (u_char *)&system_restore,sizeof(U_INT));
	break;
    case MODE_SET_RESERVE1:
	if (requests->requestvb->val_len == 0)
                return SNMP_ERR_GENERR;
        temp_restore = *((long *)requests->requestvb->val.integer);
        if(requests->requestvb->type != ASN_INTEGER)
                netsnmp_set_request_error(reqinfo, requests,SNMP_ERR_WRONGTYPE);
	if(temp_restore == 0 || temp_restore == 1)
                check_flag_restore = 0;
        else
                check_flag_restore = 1;
        if(check_flag_restore)
                netsnmp_set_request_error(reqinfo, requests,SNMP_ERR_WRONGVALUE);

	break;
    case MODE_SET_RESERVE2:
        break;
    case MODE_SET_FREE:
        break;
    case MODE_SET_ACTION:
        if(temp_restore == 1)
        {
                temp_restore = 0;
                /*if we got broad, this will replace real "restore" function*/
                printf("start restoring.........\n");
        }

	break;
    case MODE_SET_COMMIT:
        break;
    case MODE_SET_UNDO:
	 temp_restore = 0;
        break;
    default:
        return SNMP_ERR_GENERR;
    }
    return SNMP_ERR_NOERROR;
}
/***************************************************
*       for dlkEnterpriseWirelessInfo leaf node
****************************************************/
 
int
handle_enterpriseSSID(netsnmp_mib_handler *handler,
                      netsnmp_handler_registration *reginfo,
                      netsnmp_agent_request_info *reqinfo,
                      netsnmp_request_info *requests)
{
    static char temp_ssid[1024];
    static char wireless_ssid[64] = "dlink";
    switch (reqinfo->mode) {
    case MODE_GET:
        snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,
                                 (u_char *)&wireless_ssid,strlen(wireless_ssid));
	break;
    case MODE_SET_RESERVE1:
	if(requests->requestvb->type != ASN_OCTET_STR)
                netsnmp_set_request_error(reqinfo, requests,SNMP_ERR_WRONGTYPE);
	else
		memset(temp_ssid,0,sizeof(temp_ssid));
	if(requests->requestvb->val_len == 0)
		netsnmp_set_request_error(reqinfo, requests,SNMP_ERR_WRONGVALUE);
	else
		memcpy(temp_ssid,requests->requestvb->val.string,requests->requestvb->val_len);
	if((strlen(temp_ssid) > 32) || (strcmp(temp_ssid,"NULL") == 0) || (strcmp(temp_ssid,"") == 0))
		netsnmp_set_request_error(reqinfo, requests,SNMP_ERR_WRONGVALUE);	
    case MODE_SET_RESERVE2:
        break;
    case MODE_SET_FREE:
        break;
    case MODE_SET_ACTION:
	memset(wireless_ssid,0,sizeof(wireless_ssid));
	memcpy(wireless_ssid,temp_ssid,strlen(temp_ssid));
        break;
    case MODE_SET_COMMIT:
        break;
    case MODE_SET_UNDO:
        break;
    default:
        return SNMP_ERR_GENERR;
    }
    return SNMP_ERR_NOERROR;
}

int
handle_enterpriseChannel(netsnmp_mib_handler *handler,
                         netsnmp_handler_registration *reginfo,
                         netsnmp_agent_request_info *reqinfo,
                         netsnmp_request_info *requests)
{
    static U_INT temp_channel;
    switch (reqinfo->mode) {
    case MODE_GET:
        snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
                                 (u_char *)&wireless_channel,sizeof(U_INT));
	break;
    case MODE_SET_RESERVE1:
	if(requests->requestvb->type != ASN_INTEGER)
                netsnmp_set_request_error(reqinfo, requests,SNMP_ERR_WRONGTYPE);
	if (requests->requestvb->val_len == 0)
		return SNMP_ERR_GENERR;
	temp_channel = *((long *)requests->requestvb->val.integer);
	if(temp_channel > 13 || temp_channel < 1)
		netsnmp_set_request_error(reqinfo, requests,SNMP_ERR_WRONGVALUE);		
	break;
    case MODE_SET_RESERVE2:
        break;
    case MODE_SET_FREE:
        break;
    case MODE_SET_ACTION:
	wireless_channel = temp_channel;
        break;
    case MODE_SET_COMMIT:
        break;
    case MODE_SET_UNDO:
        break;
    default:
        return SNMP_ERR_GENERR;
    }
    return SNMP_ERR_NOERROR;
}

int
handle_enterpriseDataRate(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info *reqinfo,
                          netsnmp_request_info *requests)
{
    static U_INT temp_data_rate;
    switch (reqinfo->mode) {
    case MODE_GET:
        snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
                                 (u_char *)&wireless_data_rate,sizeof(U_INT));
	break;
    case MODE_SET_RESERVE1:
	if (requests->requestvb->val_len == 0)
                return SNMP_ERR_GENERR;
        temp_data_rate = *((long *)requests->requestvb->val.integer);
        if(requests->requestvb->type != ASN_INTEGER)
                netsnmp_set_request_error(reqinfo, requests,SNMP_ERR_WRONGTYPE);
	if(temp_data_rate > 12 || temp_data_rate < 0)
                netsnmp_set_request_error(reqinfo, requests,SNMP_ERR_WRONGVALUE);
	break;
    case MODE_SET_RESERVE2:
        break;
    case MODE_SET_FREE:
        break;
    case MODE_SET_ACTION:
        wireless_data_rate = temp_data_rate;
	break;
    case MODE_SET_COMMIT:
        break;
    case MODE_SET_UNDO:
	wireless_data_rate = 0;
        break;
    default:
        return SNMP_ERR_GENERR;
    }
    return SNMP_ERR_NOERROR;
}

int
handle_enterpriseFragmentLength(netsnmp_mib_handler *handler,
                                netsnmp_handler_registration *reginfo,
                                netsnmp_agent_request_info *reqinfo,
                                netsnmp_request_info *requests)
{
    static U_INT temp_fragment_length;
    switch (reqinfo->mode) {
    case MODE_GET:
        snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
                                 (u_char *)&wireless_fragment_length,sizeof(U_INT));
	break;
    case MODE_SET_RESERVE1:
	if (requests->requestvb->val_len == 0)
                return SNMP_ERR_GENERR;
	temp_fragment_length = *((long *)requests->requestvb->val.integer);
        if(requests->requestvb->type != ASN_INTEGER)
                netsnmp_set_request_error(reqinfo, requests,SNMP_ERR_WRONGTYPE);
	if(temp_fragment_length > 2346 || temp_fragment_length < 256)
                netsnmp_set_request_error(reqinfo, requests,SNMP_ERR_WRONGVALUE);

        break;
    case MODE_SET_RESERVE2:
        break;
    case MODE_SET_FREE:
        break;
    case MODE_SET_ACTION:
	wireless_fragment_length = temp_fragment_length;
        break;
    case MODE_SET_COMMIT:
        break;
    case MODE_SET_UNDO:
	wireless_fragment_length = 1000;
        break;
    default:
        return SNMP_ERR_GENERR;
    }
    return SNMP_ERR_NOERROR;
}

int
handle_enterpriseRTSLength(netsnmp_mib_handler *handler,
                           netsnmp_handler_registration *reginfo,
                           netsnmp_agent_request_info *reqinfo,
                           netsnmp_request_info *requests)
{
    static U_INT temp_RTS_length;
    switch (reqinfo->mode) {
    case MODE_GET:
        snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
                                 (u_char *)&wireless_RTS_length,sizeof(U_INT));
	break;
    case MODE_SET_RESERVE1:
	if (requests->requestvb->val_len == 0)
                return SNMP_ERR_GENERR;
        temp_RTS_length = *((long *)requests->requestvb->val.integer);
        if(requests->requestvb->type != ASN_INTEGER)
                netsnmp_set_request_error(reqinfo, requests,SNMP_ERR_WRONGTYPE);
	if(temp_RTS_length > 2346 || temp_RTS_length < 1)
                netsnmp_set_request_error(reqinfo, requests,SNMP_ERR_WRONGVALUE);
	break;
    case MODE_SET_RESERVE2:
        break;
    case MODE_SET_FREE:
        break;
    case MODE_SET_ACTION:
        wireless_RTS_length = temp_RTS_length;
	break;
    case MODE_SET_COMMIT:
        break;
    case MODE_SET_UNDO:
	wireless_RTS_length = 1000;
        break;
    default:
        return SNMP_ERR_GENERR;
    }
    return SNMP_ERR_NOERROR;
}

int
handle_enterpriseTransmitPower(netsnmp_mib_handler *handler,
                               netsnmp_handler_registration *reginfo,
                               netsnmp_agent_request_info *reqinfo,
                               netsnmp_request_info *requests)
{
    static U_INT temp_transmit_power;
    switch (reqinfo->mode) {
    case MODE_GET:
	snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
                                 (u_char *)&wireless_transmit_power,sizeof(U_INT));
        break;
    case MODE_SET_RESERVE1:
	if (requests->requestvb->val_len == 0)
                return SNMP_ERR_GENERR;
	temp_transmit_power = *((long *)requests->requestvb->val.integer);
        if(requests->requestvb->type != ASN_INTEGER)
                netsnmp_set_request_error(reqinfo, requests,SNMP_ERR_WRONGTYPE);
	if(temp_transmit_power > 5 || temp_transmit_power < 1)
                netsnmp_set_request_error(reqinfo, requests,SNMP_ERR_WRONGVALUE);
        break;
    case MODE_SET_RESERVE2:
        break;
    case MODE_SET_FREE:
        break;
    case MODE_SET_ACTION:
	wireless_transmit_power = temp_transmit_power;
        break;
    case MODE_SET_COMMIT:
        break;
    case MODE_SET_UNDO:
	wireless_transmit_power = 1;
        break;
    default:
        return SNMP_ERR_GENERR;
    }
    return SNMP_ERR_NOERROR;
}

int
handle_enterpriseBGMode(netsnmp_mib_handler *handler,
                        netsnmp_handler_registration *reginfo,
                        netsnmp_agent_request_info *reqinfo,
                        netsnmp_request_info *requests)
{
    static U_INT temp_bgmode;
    switch (reqinfo->mode) {
    case MODE_GET:
	snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
                                 (u_char *)&wireless_bgmode,sizeof(U_INT));
        break;
    case MODE_SET_RESERVE1:
	if (requests->requestvb->val_len == 0)
                return SNMP_ERR_GENERR;
        temp_bgmode = *((long *)requests->requestvb->val.integer);
	if(requests->requestvb->type != ASN_INTEGER)
		netsnmp_set_request_error(reqinfo, requests,SNMP_ERR_WRONGTYPE);
        if(temp_bgmode > 2 || temp_bgmode < 0)
                netsnmp_set_request_error(reqinfo, requests,SNMP_ERR_WRONGVALUE);
	break;
    case MODE_SET_RESERVE2:
        break;
    case MODE_SET_FREE:
        break;
    case MODE_SET_ACTION:
	wireless_bgmode = temp_bgmode;
        break;
    case MODE_SET_COMMIT:
        break;
    case MODE_SET_UNDO:
	wireless_bgmode = 0;
        break;
    default:
        return SNMP_ERR_GENERR;
    }
    return SNMP_ERR_NOERROR;
}

int
handle_enterpriseAntennaDiversity(netsnmp_mib_handler *handler,
                                  netsnmp_handler_registration *reginfo,
                                  netsnmp_agent_request_info *reqinfo,
                                  netsnmp_request_info *requests)
{
    static U_INT temp_antenna;
    switch (reqinfo->mode) {
    case MODE_GET:
        snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
                                 (u_char *)&wireless_antenna,sizeof(U_INT));
	break;
    case MODE_SET_RESERVE1:
	if (requests->requestvb->val_len == 0)
                return SNMP_ERR_GENERR;
	temp_antenna = *((long *)requests->requestvb->val.integer);
        if(requests->requestvb->type != ASN_INTEGER)
                netsnmp_set_request_error(reqinfo, requests,SNMP_ERR_WRONGTYPE);
        if(temp_antenna > 2 || temp_antenna < 0)
                netsnmp_set_request_error(reqinfo, requests,SNMP_ERR_WRONGVALUE);
        break;
    case MODE_SET_RESERVE2:
        break;
    case MODE_SET_FREE:
        break;
    case MODE_SET_ACTION:
	wireless_antenna = temp_antenna;
        break;
    case MODE_SET_COMMIT:
        break;
    case MODE_SET_UNDO:
	wireless_antenna = 0;
        break;
    default:
        return SNMP_ERR_GENERR;
    }
    return SNMP_ERR_NOERROR;
}

int
handle_enterpriseConnectedTime(netsnmp_mib_handler *handler,
                               netsnmp_handler_registration *reginfo,
                               netsnmp_agent_request_info *reqinfo,
                               netsnmp_request_info *requests)
{
    switch (reqinfo->mode) {
    case MODE_GET:
    snmp_set_var_typed_value(requests->requestvb, ASN_TIMETICKS,
                                 (u_char *)&wireless_connected_time,sizeof(U_INT));
	break;
    default:
        return SNMP_ERR_NOACCESS;
    }
    return SNMP_ERR_NOERROR;
}

int
handle_dlkWirelessAuthenticationType(netsnmp_mib_handler *handler,
                                     netsnmp_handler_registration *reginfo,
                                     netsnmp_agent_request_info *reqinfo,
                                     netsnmp_request_info *requests)
{
    static U_INT temp_authtype;
    switch (reqinfo->mode) {
    case MODE_GET:
        snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
                                 (u_char *)&wireless_authtype,sizeof(U_INT));
	break;
    case MODE_SET_RESERVE1:
	if (requests->requestvb->val_len == 0)
                return SNMP_ERR_GENERR;
	temp_authtype = *((long *)requests->requestvb->val.integer);
        if(requests->requestvb->type != ASN_INTEGER)
                netsnmp_set_request_error(reqinfo, requests,SNMP_ERR_WRONGTYPE);
        if(temp_authtype > 9 || temp_authtype < 0)
                netsnmp_set_request_error(reqinfo, requests,SNMP_ERR_WRONGVALUE);
	
        break;
    case MODE_SET_RESERVE2:
        break;
    case MODE_SET_FREE:
        break;
    case MODE_SET_ACTION:
	wireless_authtype = temp_authtype;
        break;
    case MODE_SET_COMMIT:
        break;
    case MODE_SET_UNDO:
        wireless_authtype = 0;
	break;
    default:
        return SNMP_ERR_GENERR;
    }
    return SNMP_ERR_NOERROR;
}

int
handle_dlkWirelessWEPKeyType(netsnmp_mib_handler *handler,
                             netsnmp_handler_registration *reginfo,
                             netsnmp_agent_request_info *reqinfo,
                             netsnmp_request_info *requests)
{
    static U_INT temp_wepkey_type;
    static U_INT temp_wepkey_flag;
    switch (reqinfo->mode) {

    case MODE_GET:
        snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
                                 (u_char *)&wireless_wepkey_type,sizeof(U_INT));
	break;
    case MODE_SET_RESERVE1:
	if (requests->requestvb->val_len == 0)
                return SNMP_ERR_GENERR;
	temp_wepkey_type = *((long *)requests->requestvb->val.integer);
        if(requests->requestvb->type != ASN_INTEGER)
                netsnmp_set_request_error(reqinfo, requests,SNMP_ERR_WRONGTYPE);
        if(temp_wepkey_type > 1 || temp_wepkey_type < 0)
                netsnmp_set_request_error(reqinfo, requests,SNMP_ERR_WRONGVALUE);
	if((wireless_authtype == 1) || (wireless_authtype == 2) || (wireless_authtype == 3))
		temp_wepkey_flag = 1;
	else
		temp_wepkey_flag = 0;
	if(!temp_wepkey_flag)
		netsnmp_set_request_error(reqinfo, requests,SNMP_ERR_NOACCESS);
        break;
    case MODE_SET_RESERVE2:
        break;
    case MODE_SET_FREE:
        break;
    case MODE_SET_ACTION:
	wireless_wepkey_type = temp_wepkey_type;
        break;
    case MODE_SET_COMMIT:
        break;
    case MODE_SET_UNDO:
	wireless_wepkey_type = 0;
        break;
    default:
        return SNMP_ERR_GENERR;
    }
    return SNMP_ERR_NOERROR;
}

int
handle_dlkWirelessWEPKeySize(netsnmp_mib_handler *handler,
                             netsnmp_handler_registration *reginfo,
                             netsnmp_agent_request_info *reqinfo,
                             netsnmp_request_info *requests)
{
    static U_INT temp_wepkey_size;
    static U_INT temp_wepkey_size_flag;
    switch (reqinfo->mode) {

    case MODE_GET:
        snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
                                 (u_char *)&wireless_wepkey_size,sizeof(U_INT));
        break;
    case MODE_SET_RESERVE1:
	if (requests->requestvb->val_len == 0)
                return SNMP_ERR_GENERR;
        temp_wepkey_size = *((long *)requests->requestvb->val.integer);
        if(requests->requestvb->type != ASN_INTEGER)
                netsnmp_set_request_error(reqinfo, requests,SNMP_ERR_WRONGTYPE);
        if(temp_wepkey_size > 2 || temp_wepkey_size < 0)
                netsnmp_set_request_error(reqinfo, requests,SNMP_ERR_WRONGVALUE);
        if((wireless_authtype == 1) || (wireless_authtype == 2) || (wireless_authtype == 3))
                temp_wepkey_size_flag = 1;
        else
                temp_wepkey_size_flag = 0;
        if(!temp_wepkey_size_flag)
                netsnmp_set_request_error(reqinfo, requests,SNMP_ERR_NOACCESS);
        break;
    case MODE_SET_RESERVE2:
        break;
    case MODE_SET_FREE:
        break;
    case MODE_SET_ACTION:
        wireless_wepkey_size = temp_wepkey_size;
        break;
    case MODE_SET_COMMIT:
        break;
    case MODE_SET_UNDO:
        wireless_wepkey_size = 0;
        break;
    default:
        return SNMP_ERR_GENERR;
    }
    return SNMP_ERR_NOERROR;
}
int
handle_dlkWirelessWEPValidKey(netsnmp_mib_handler *handler,
                              netsnmp_handler_registration *reginfo,
                              netsnmp_agent_request_info *reqinfo,
                              netsnmp_request_info *requests)
{
    static U_INT temp_valid_key;
    static U_INT temp_valid_key_flag;
    switch (reqinfo->mode) {
    case MODE_GET:
         snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
                                 (u_char *)&wireless_valid_key,sizeof(U_INT));
	break;
    case MODE_SET_RESERVE1:
	if (requests->requestvb->val_len == 0)
                return SNMP_ERR_GENERR;
	temp_valid_key = *((long *)requests->requestvb->val.integer);
        if(requests->requestvb->type != ASN_INTEGER)
                netsnmp_set_request_error(reqinfo, requests,SNMP_ERR_WRONGTYPE);
        if(temp_valid_key > 4 || temp_valid_key < 1)
                netsnmp_set_request_error(reqinfo, requests,SNMP_ERR_WRONGVALUE);
        if((wireless_authtype == 1) || (wireless_authtype == 2) || (wireless_authtype == 3))
                temp_valid_key_flag = 1;
        else
                temp_valid_key_flag = 0;
        if(!temp_valid_key_flag)
                netsnmp_set_request_error(reqinfo, requests,SNMP_ERR_NOACCESS);
        break;
    case MODE_SET_RESERVE2:
        break;
    case MODE_SET_FREE:
        break;
    case MODE_SET_ACTION:
	wireless_valid_key = temp_valid_key;
        break;
    case MODE_SET_COMMIT:
        break;
    case MODE_SET_UNDO:
	wireless_valid_key = 1;	
        break;
    default:
        return SNMP_ERR_GENERR;
    }
    return SNMP_ERR_NOERROR;
}

int
handle_dlkWirelessWPAPassPhrase(netsnmp_mib_handler *handler,
                              	netsnmp_handler_registration *reginfo,
                              	netsnmp_agent_request_info *reqinfo,
                              	netsnmp_request_info *requests)
{

    static char wpa_passPhrase[64] = "aaaaaaaa";
    static char temp_passPhrase[128];
    static U_INT temp_passPhrase_flag;

    switch (reqinfo->mode) {
    case MODE_GET:
        snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,
                                 (u_char *)&wpa_passPhrase,strlen(wpa_passPhrase));
        break;
    case MODE_SET_RESERVE1:
        if(requests->requestvb->type != ASN_OCTET_STR)
                netsnmp_set_request_error(reqinfo, requests,SNMP_ERR_WRONGTYPE);
        else
                memset(temp_passPhrase,0,sizeof(temp_passPhrase));
        if(requests->requestvb->val_len == 0)
                netsnmp_set_request_error(reqinfo, requests,SNMP_ERR_WRONGVALUE);
        else
                memcpy(temp_passPhrase,requests->requestvb->val.string,requests->requestvb->val_len);
        if((strlen(temp_passPhrase) > 64) || (strlen(temp_passPhrase) < 8) || (strcmp(temp_passPhrase,"NULL") == 0) || (strcmp(temp_passPhrase,"") == 0))
                netsnmp_set_request_error(reqinfo, requests,SNMP_ERR_WRONGVALUE);

        if((wireless_authtype == 5) || (wireless_authtype == 7) || (wireless_authtype == 9))
                temp_passPhrase_flag = 1;
        else
                temp_passPhrase_flag = 0;
        if(!temp_passPhrase_flag)
                netsnmp_set_request_error(reqinfo, requests,SNMP_ERR_NOACCESS);
        break;
    case MODE_SET_RESERVE2:
        break;
    case MODE_SET_FREE:
        break;
    case MODE_SET_ACTION:
        memset(wpa_passPhrase,0,sizeof(wpa_passPhrase));
        memcpy(wpa_passPhrase,temp_passPhrase,strlen(temp_passPhrase));
        break;
    case MODE_SET_COMMIT:
        break;
    case MODE_SET_UNDO:
        break;
    default:
        return SNMP_ERR_GENERR;
    }
    return SNMP_ERR_NOERROR;
}


int
handle_dlkWirelessWEPKeyOne(netsnmp_mib_handler *handler,
                            netsnmp_handler_registration *reginfo,
                            netsnmp_agent_request_info *reqinfo,
                            netsnmp_request_info *requests)
{
    static char temp_wep_key_one[1024];
    static U_INT temp_wep_key_one_flag;
    
    switch (reqinfo->mode) {
    case MODE_GET:
	snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,
                                 (u_char *)&wep_key_one,strlen(wep_key_one));
	break;
    case MODE_SET_RESERVE1:
	memcpy(temp_wep_key_one,requests->requestvb->val.string,requests->requestvb->val_len);
        if(requests->requestvb->type != ASN_OCTET_STR)
                netsnmp_set_request_error(reqinfo, requests,SNMP_ERR_WRONGTYPE);
	if((wireless_authtype == 1) || (wireless_authtype == 2) || (wireless_authtype == 3))
                temp_wep_key_one_flag = 1;
        else
                temp_wep_key_one_flag = 0;
        if(!temp_wep_key_one_flag)
                netsnmp_set_request_error(reqinfo, requests,SNMP_ERR_NOACCESS);	
	break;
    case MODE_SET_RESERVE2:
        break;
    case MODE_SET_FREE:
        break;
    case MODE_SET_ACTION:
	check_wep_input_format(1,temp_wep_key_one,reqinfo,requests);
        break;
    case MODE_SET_COMMIT:
        break;
    case MODE_SET_UNDO:
        break;
    default:
        return SNMP_ERR_GENERR;
    }
    return SNMP_ERR_NOERROR;
}

int
handle_dlkWirelessWEPKeyTwo(netsnmp_mib_handler *handler,
                            netsnmp_handler_registration *reginfo,
                            netsnmp_agent_request_info *reqinfo,
                            netsnmp_request_info *requests)
{
    static char temp_wep_key_two[1024];
    static U_INT temp_wep_key_two_flag;

    switch (reqinfo->mode) {
    case MODE_GET:
        snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,
                                 (u_char *)&wep_key_two,strlen(wep_key_two));
        break;
    case MODE_SET_RESERVE1:
        memcpy(temp_wep_key_two,requests->requestvb->val.string,requests->requestvb->val_len);
        if(requests->requestvb->type != ASN_OCTET_STR)
                netsnmp_set_request_error(reqinfo, requests,SNMP_ERR_WRONGTYPE);
        if((wireless_authtype == 1) || (wireless_authtype == 2) || (wireless_authtype == 3))
                temp_wep_key_two_flag = 1;
        else
                temp_wep_key_two_flag = 0;
        if(!temp_wep_key_two_flag)
                netsnmp_set_request_error(reqinfo, requests,SNMP_ERR_NOACCESS);
        break;
    case MODE_SET_RESERVE2:
        break;
    case MODE_SET_FREE:
        break;
    case MODE_SET_ACTION:
        check_wep_input_format(2,temp_wep_key_two,reqinfo,requests);
        break;
    case MODE_SET_COMMIT:
        break;
    case MODE_SET_UNDO:
        break;
    default:
        return SNMP_ERR_GENERR;
    }
    return SNMP_ERR_NOERROR;
}

int
handle_dlkWirelessWEPKeyThree(netsnmp_mib_handler *handler,
                            netsnmp_handler_registration *reginfo,
                            netsnmp_agent_request_info *reqinfo,
                            netsnmp_request_info *requests)
{
    static char temp_wep_key_three[1024];
    static U_INT temp_wep_key_three_flag;

    switch (reqinfo->mode) {
    case MODE_GET:
        snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,
                                 (u_char *)&wep_key_three,strlen(wep_key_three));
        break;
    case MODE_SET_RESERVE1:
        memcpy(temp_wep_key_three,requests->requestvb->val.string,requests->requestvb->val_len);
        if(requests->requestvb->type != ASN_OCTET_STR)
                netsnmp_set_request_error(reqinfo, requests,SNMP_ERR_WRONGTYPE);
        if((wireless_authtype == 1) || (wireless_authtype == 2) || (wireless_authtype == 3))
                temp_wep_key_three_flag = 1;
        else
                temp_wep_key_three_flag = 0;
        if(!temp_wep_key_three_flag)
                netsnmp_set_request_error(reqinfo, requests,SNMP_ERR_NOACCESS);
        break;
    case MODE_SET_RESERVE2:
        break;
    case MODE_SET_FREE:
        break;
    case MODE_SET_ACTION:
        check_wep_input_format(3,temp_wep_key_three,reqinfo,requests);
        break;
    case MODE_SET_COMMIT:
        break;
    case MODE_SET_UNDO:
        break;
    default:
        return SNMP_ERR_GENERR;
    }
    return SNMP_ERR_NOERROR;
}

int
handle_dlkWirelessWEPKeyFour(netsnmp_mib_handler *handler,
                            netsnmp_handler_registration *reginfo,
                            netsnmp_agent_request_info *reqinfo,
                            netsnmp_request_info *requests)
{
    static char temp_wep_key_four[1024];
    static U_INT temp_wep_key_four_flag;

    switch (reqinfo->mode) {
    case MODE_GET:
        snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,
                                 (u_char *)&wep_key_four,strlen(wep_key_four));
        break;
    case MODE_SET_RESERVE1:
        memcpy(temp_wep_key_four,requests->requestvb->val.string,requests->requestvb->val_len);
        if(requests->requestvb->type != ASN_OCTET_STR)
                netsnmp_set_request_error(reqinfo, requests,SNMP_ERR_WRONGTYPE);
        if((wireless_authtype == 1) || (wireless_authtype == 2) || (wireless_authtype == 3))
                temp_wep_key_four_flag = 1;
        else
                temp_wep_key_four_flag = 0;
        if(!temp_wep_key_four_flag)
                netsnmp_set_request_error(reqinfo, requests,SNMP_ERR_NOACCESS);
        break;
    case MODE_SET_RESERVE2:
        break;
    case MODE_SET_FREE:
        break;
    case MODE_SET_ACTION:
        check_wep_input_format(4,temp_wep_key_four,reqinfo,requests);
        break;
    case MODE_SET_COMMIT:
        break;
    case MODE_SET_UNDO:
        break;
    default:
        return SNMP_ERR_GENERR;
    }
    return SNMP_ERR_NOERROR;
}

int
handle_dlkWirelessEAPType(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info *reqinfo,
                          netsnmp_request_info *requests)
{
    static U_INT temp_wpa_eap_type;
    static U_INT temp_wpa_eap_type_flag;
    switch (reqinfo->mode) {
    case MODE_GET:
        snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
                                 (u_char *)&wireless_wpa_eap_type,sizeof(wireless_wpa_eap_type));
	break;
    case MODE_SET_RESERVE1:
	if (requests->requestvb->val_len == 0)
                return SNMP_ERR_GENERR;
        temp_wpa_eap_type = *((long *)requests->requestvb->val.integer);
        if(requests->requestvb->type != ASN_INTEGER)
                netsnmp_set_request_error(reqinfo, requests,SNMP_ERR_WRONGTYPE);
        if(temp_wpa_eap_type > 1 || temp_wpa_eap_type < 0)
                netsnmp_set_request_error(reqinfo, requests,SNMP_ERR_WRONGVALUE);
        if((wireless_authtype == 4) || (wireless_authtype == 6) || (wireless_authtype == 8))
                temp_wpa_eap_type_flag = 1;
        else
                temp_wpa_eap_type_flag = 0;
        if(!temp_wpa_eap_type_flag)
                netsnmp_set_request_error(reqinfo, requests,SNMP_ERR_NOACCESS);
	break;
    case MODE_SET_RESERVE2:
        break;
    case MODE_SET_FREE:
        break;
    case MODE_SET_ACTION:
	wireless_wpa_eap_type = temp_wpa_eap_type;
        break;
    case MODE_SET_COMMIT:
        break;
    case MODE_SET_UNDO:
        break;
    default:
        return SNMP_ERR_GENERR;
    }
    return SNMP_ERR_NOERROR;
}

int
handle_dlkWirelessAuthType(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info *reqinfo,
                          netsnmp_request_info *requests)
{
    static U_INT temp_wpa_auth_type;
    static U_INT temp_wpa_auth_type_flag;
    switch (reqinfo->mode) {
    case MODE_GET:
        snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
                                 (u_char *)&wireless_wpa_auth_type,sizeof(wireless_wpa_auth_type));
        break;
    case MODE_SET_RESERVE1:
	if (requests->requestvb->val_len == 0)
                return SNMP_ERR_GENERR;
        temp_wpa_auth_type = *((long *)requests->requestvb->val.integer);
        if(requests->requestvb->type != ASN_INTEGER)
                netsnmp_set_request_error(reqinfo, requests,SNMP_ERR_WRONGTYPE);
        if(temp_wpa_auth_type > 1 || temp_wpa_auth_type < 0)
                netsnmp_set_request_error(reqinfo, requests,SNMP_ERR_WRONGVALUE);
        if((wireless_authtype == 4) || (wireless_authtype == 6) || (wireless_authtype == 8))
                temp_wpa_auth_type_flag = 1;
        else
                temp_wpa_auth_type_flag = 0;
        if(!temp_wpa_auth_type_flag)
                netsnmp_set_request_error(reqinfo, requests,SNMP_ERR_NOACCESS);
        break;
    case MODE_SET_RESERVE2:
        break;
    case MODE_SET_FREE:
        break;
    case MODE_SET_ACTION:
        wireless_wpa_auth_type = temp_wpa_auth_type;
        break;
    case MODE_SET_COMMIT:
        break;
    case MODE_SET_UNDO:
        break;
    default:
        return SNMP_ERR_GENERR;
    }
    return SNMP_ERR_NOERROR;
}

int
handle_dlkWirelessCertificate(netsnmp_mib_handler *handler,
                              netsnmp_handler_registration *reginfo,
                              netsnmp_agent_request_info *reqinfo,
                              netsnmp_request_info *requests)
{
    static char wpa_certificate_path[128] = "C:\\Documents and Settings\\Administrator\\My Documents\\Certificate.xxx";
    static char temp_certificate_path[1024];
    static U_INT temp_certificate_path_flag;

    switch (reqinfo->mode) {
    case MODE_GET:
        snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,
                                 (u_char *)&wpa_certificate_path,strlen(wpa_certificate_path));
        break;
    case MODE_SET_RESERVE1:
        if(requests->requestvb->type != ASN_OCTET_STR)
                netsnmp_set_request_error(reqinfo, requests,SNMP_ERR_WRONGTYPE);
        else
                memset(temp_certificate_path,0,sizeof(temp_certificate_path));
        if(requests->requestvb->val_len == 0)
                netsnmp_set_request_error(reqinfo, requests,SNMP_ERR_WRONGVALUE);
        else
                memcpy(temp_certificate_path,requests->requestvb->val.string,requests->requestvb->val_len);
	if((strlen(temp_certificate_path) > 128) || (strcmp(temp_certificate_path,"NULL") == 0) || (strcmp(temp_certificate_path,"") == 0))
                netsnmp_set_request_error(reqinfo, requests,SNMP_ERR_WRONGVALUE);

	if((wireless_authtype == 4) || (wireless_authtype == 6) || (wireless_authtype == 8))
                temp_certificate_path_flag = 1;
        else
                temp_certificate_path_flag = 0;
        if(!temp_certificate_path_flag)
                netsnmp_set_request_error(reqinfo, requests,SNMP_ERR_NOACCESS);
	break;
    case MODE_SET_RESERVE2:
        break;
    case MODE_SET_FREE:
        break;
    case MODE_SET_ACTION:
        memset(wpa_certificate_path,0,sizeof(wpa_certificate_path));
        memcpy(wpa_certificate_path,temp_certificate_path,strlen(temp_certificate_path));
	break;
    case MODE_SET_COMMIT:
        break;
    case MODE_SET_UNDO:
        break;
    default:
        return SNMP_ERR_GENERR;
    }
    return SNMP_ERR_NOERROR;
}

int
handle_dlkEnterpriseWANMode(netsnmp_mib_handler *handler,
                            netsnmp_handler_registration *reginfo,
                            netsnmp_agent_request_info *reqinfo,
                            netsnmp_request_info *requests)
{
    static U_INT temp_wan_mode;
    int check_flag_wan_mode;
    switch (reqinfo->mode) {
    case MODE_GET:
        snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
                                 (u_char *)&wan_connected_mode,sizeof(U_INT));
	break;
    case MODE_SET_RESERVE1:
	if (requests->requestvb->val_len == 0)
                return SNMP_ERR_GENERR;
        temp_wan_mode = *((long *)requests->requestvb->val.integer);
        if(requests->requestvb->type != ASN_INTEGER)
                netsnmp_set_request_error(reqinfo, requests,SNMP_ERR_WRONGTYPE);
        if(temp_wan_mode == 0 || temp_wan_mode == 1)
                check_flag_wan_mode = 0;
        else
                check_flag_wan_mode = 1;
        if(check_flag_wan_mode)
                netsnmp_set_request_error(reqinfo, requests,SNMP_ERR_WRONGVALUE);
	break;
    case MODE_SET_RESERVE2:
        break;
    case MODE_SET_FREE:
        break;
    case MODE_SET_ACTION:
	wan_connected_mode = temp_wan_mode;
        break;
    case MODE_SET_COMMIT:
        break;
    case MODE_SET_UNDO:
        break;
    default:
        return SNMP_ERR_GENERR;
    }
    return SNMP_ERR_NOERROR;
}

int
handle_dlkEnterpriseWANHostName(netsnmp_mib_handler *handler,
                                netsnmp_handler_registration *reginfo,
                                netsnmp_agent_request_info *reqinfo,
                                netsnmp_request_info *requests)
{
    static char wan_host_name[64] = "dlink";
    static char temp_host_name [64];
    switch (reqinfo->mode) {
    case MODE_GET:
        snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,
                                 (u_char *)&wan_host_name,strlen(wan_host_name));
	break;
    case MODE_SET_RESERVE1:
        if(requests->requestvb->type != ASN_OCTET_STR)
                netsnmp_set_request_error(reqinfo, requests,SNMP_ERR_WRONGTYPE);
        else
                memset(temp_host_name,0,sizeof(temp_host_name));
        if(requests->requestvb->val_len == 0)
                netsnmp_set_request_error(reqinfo, requests,SNMP_ERR_WRONGVALUE);
        else
                memcpy(temp_host_name,requests->requestvb->val.string,requests->requestvb->val_len);
        if((strlen(temp_host_name) > 64) || (strcmp(temp_host_name,"NULL") == 0) || (strcmp(temp_host_name,"") == 0))
                netsnmp_set_request_error(reqinfo, requests,SNMP_ERR_WRONGVALUE);

	break;
    case MODE_SET_RESERVE2:
        break;
    case MODE_SET_FREE:
        break;
    case MODE_SET_ACTION:
	memset(wan_host_name,0,sizeof(wan_host_name));
        memcpy(wan_host_name,temp_host_name,strlen(temp_host_name));        
	break;
    case MODE_SET_COMMIT:
        break;
    case MODE_SET_UNDO:
        break;
    default:
        return SNMP_ERR_GENERR;
    }
    return SNMP_ERR_NOERROR;
}

int
handle_dlkEnterpriseWANMacAddress(netsnmp_mib_handler *handler,
                                  netsnmp_handler_registration *reginfo,
                                  netsnmp_agent_request_info *reqinfo,
                                  netsnmp_request_info *requests)
{
    static char temp_wan_mac[64];
    static U_INT to_hex[WANMACLENGTH];
    int i;
    switch (reqinfo->mode) {
    case MODE_GET:
        snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,
                                 (u_char *)&wan_mac,WANMACLENGTH);
        break;
    case MODE_SET_RESERVE1:
        if(requests->requestvb->type != ASN_OCTET_STR)
                netsnmp_set_request_error(reqinfo, requests,SNMP_ERR_WRONGTYPE);
	else
                memset(temp_wan_mac,0,sizeof(temp_wan_mac));
	 if(requests->requestvb->val_len == 0)
                netsnmp_set_request_error(reqinfo, requests,SNMP_ERR_WRONGVALUE);
        else
                memcpy(temp_wan_mac,requests->requestvb->val.string,requests->requestvb->val_len);		
	if(!mac_check(temp_wan_mac))
		netsnmp_set_request_error(reqinfo, requests,SNMP_ERR_WRONGVALUE);
	break;
    case MODE_SET_RESERVE2:
        break;
    case MODE_SET_FREE:
        break;
    case MODE_SET_ACTION:
	sscanf(temp_wan_mac,"%x:%x:%x:%x:%x:%x",&to_hex[0],&to_hex[1],&to_hex[2],&to_hex[3],&to_hex[4],&to_hex[5]);
	memset(wan_mac,0,sizeof(wan_mac));
	
	for(i=0;i<6;i++)
		wan_mac[i] = (char *)to_hex[i];
        break;
    case MODE_SET_COMMIT:
        break;
    case MODE_SET_UNDO:
        break;
    default:
        return SNMP_ERR_GENERR;
    }
    return SNMP_ERR_NOERROR;
}

int
handle_dlkEnterpriseWANCloneMac(netsnmp_mib_handler *handler,
                                netsnmp_handler_registration *reginfo,
                                netsnmp_agent_request_info *reqinfo,
                                netsnmp_request_info *requests)
{
    static U_INT temp_clone_mac;
    int check_flag_clone_mac;
    switch (reqinfo->mode) {
    case MODE_GET:
        snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
                                 (u_char *)&wan_clone_mac,sizeof(U_INT));
	break;
    case MODE_SET_RESERVE1:
	if (requests->requestvb->val_len == 0)
                return SNMP_ERR_GENERR;
        temp_clone_mac = *((long *)requests->requestvb->val.integer);
        if(requests->requestvb->type != ASN_INTEGER)
                netsnmp_set_request_error(reqinfo, requests,SNMP_ERR_WRONGTYPE);
        if(temp_clone_mac == 0 || temp_clone_mac == 1)
                check_flag_clone_mac = 0;
        else
                check_flag_clone_mac = 1;
        if(check_flag_clone_mac)
                netsnmp_set_request_error(reqinfo, requests,SNMP_ERR_WRONGVALUE);
	break;
    case MODE_SET_RESERVE2:
        break;
    case MODE_SET_FREE:
        break;
    case MODE_SET_ACTION:
	if(temp_clone_mac)
	{
		printf("do clone mac function\n");
		wan_clone_mac = 0;
	}
        break;
    case MODE_SET_COMMIT:
        break;
    case MODE_SET_UNDO:
        break;
    default:
        return SNMP_ERR_GENERR;
    }
    return SNMP_ERR_NOERROR;
}

int
handle_dlkEnterpriseWANPrimaryDNS(netsnmp_mib_handler *handler,
                                  netsnmp_handler_registration *reginfo,
                                  netsnmp_agent_request_info *reqinfo,
                                  netsnmp_request_info *requests)
{
    static struct in_addr primaryDNS;
    static char temp_dns_1[] = "168.95.1.1";

    switch (reqinfo->mode) {
    case MODE_GET:
        inet_aton(temp_dns_1,&primaryDNS);
        snmp_set_var_typed_value(requests->requestvb, ASN_IPADDRESS,(u_char *)&primaryDNS.s_addr,sizeof(long));
	break;
    case MODE_SET_RESERVE1:
        if(requests->requestvb->type != ASN_IPADDRESS)
                netsnmp_set_request_error(reqinfo, requests,SNMP_ERR_WRONGTYPE);
	memset(&primaryDNS,0,sizeof(primaryDNS));
	break;
    case MODE_SET_RESERVE2:
        break;
    case MODE_SET_FREE:
        break;
    case MODE_SET_ACTION:
        primaryDNS.s_addr = *((long *)requests->requestvb->val.string);
        if(strcmp(inet_ntoa(primaryDNS),"NULL") == 0)
		netsnmp_set_request_error(reqinfo, requests,SNMP_ERR_WRONGVALUE);
	if(check_illegal_ip(inet_ntoa(primaryDNS)) == -1)
                netsnmp_set_request_error(reqinfo, requests,SNMP_ERR_WRONGVALUE);
        else
                strcpy(temp_dns_1,inet_ntoa(primaryDNS));

	break;
    case MODE_SET_COMMIT:
        break;
    case MODE_SET_UNDO:
        break;
    default:
        return SNMP_ERR_GENERR;
    }
    return SNMP_ERR_NOERROR;
}

int
handle_dlkEnterpriseWANSecondaryDNS(netsnmp_mib_handler *handler,
                                    netsnmp_handler_registration *reginfo,
                                    netsnmp_agent_request_info *reqinfo,
                                    netsnmp_request_info *requests)
{
    static struct in_addr secondaryDNS;
    static char temp_dns_2[] = "10.0.1.1";

    switch (reqinfo->mode) {
    case MODE_GET:
        inet_aton(temp_dns_2,&secondaryDNS);
        snmp_set_var_typed_value(requests->requestvb, ASN_IPADDRESS,(u_char *)&secondaryDNS.s_addr,sizeof(long));
        break;
    case MODE_SET_RESERVE1:
        if(requests->requestvb->type != ASN_IPADDRESS)
                netsnmp_set_request_error(reqinfo, requests,SNMP_ERR_WRONGTYPE);
        memset(&secondaryDNS,0,sizeof(secondaryDNS));
        break;
    case MODE_SET_RESERVE2:
        break;
    case MODE_SET_FREE:
        break;
    case MODE_SET_ACTION:
        secondaryDNS.s_addr = *((long *)requests->requestvb->val.string);
        if(strcmp(inet_ntoa(secondaryDNS),"NULL") == 0)
                netsnmp_set_request_error(reqinfo, requests,SNMP_ERR_WRONGVALUE);
        if(check_illegal_ip(inet_ntoa(secondaryDNS)) == -1)
                netsnmp_set_request_error(reqinfo, requests,SNMP_ERR_WRONGVALUE);
        else
                strcpy(temp_dns_2,inet_ntoa(secondaryDNS));

        break;
    case MODE_SET_COMMIT:
        break;
    case MODE_SET_UNDO:
        break;
    default:
        return SNMP_ERR_GENERR;
    }
    return SNMP_ERR_NOERROR;
}

int
handle_dlkEnterpriseWANMTU(netsnmp_mib_handler *handler,
                           netsnmp_handler_registration *reginfo,
                           netsnmp_agent_request_info *reqinfo,
                           netsnmp_request_info *requests)
{
    static U_INT temp_mtu;
    switch (reqinfo->mode) {
    case MODE_GET:
        snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
                                 (u_char *)&wan_mtu,sizeof(U_INT));
	break;
    case MODE_SET_RESERVE1:
	if (requests->requestvb->val_len == 0)
                return SNMP_ERR_GENERR;
        temp_mtu = *((long *)requests->requestvb->val.integer);
        if(requests->requestvb->type != ASN_INTEGER)
                netsnmp_set_request_error(reqinfo, requests,SNMP_ERR_WRONGTYPE);
        if(temp_mtu > 1500 || temp_mtu < 1400)
                netsnmp_set_request_error(reqinfo, requests,SNMP_ERR_WRONGVALUE);
	break;
    case MODE_SET_RESERVE2:
        break;
    case MODE_SET_FREE:
        break;
    case MODE_SET_ACTION:
        wan_mtu = temp_mtu;
	break;
    case MODE_SET_COMMIT:
        break;
    case MODE_SET_UNDO:
        break;
    default:
        return SNMP_ERR_GENERR;
    }
    return SNMP_ERR_NOERROR;
}

int
handle_dlkEnterpriseWANIPAddress(netsnmp_mib_handler *handler,
                                 netsnmp_handler_registration *reginfo,
                                 netsnmp_agent_request_info *reqinfo,
                                 netsnmp_request_info *requests)
{
    static struct in_addr wanip;
    static char temp_wanip[] = "10.0.0.1";

    switch (reqinfo->mode) {
    case MODE_GET:
        inet_aton(temp_wanip,&wanip);
        snmp_set_var_typed_value(requests->requestvb, ASN_IPADDRESS,(u_char *)&wanip.s_addr,sizeof(long));
        break;
    case MODE_SET_RESERVE1:
        if(requests->requestvb->type != ASN_IPADDRESS)
                netsnmp_set_request_error(reqinfo, requests,SNMP_ERR_WRONGTYPE);
        if(wan_connected_mode == 1)
                memset(&wanip,0,sizeof(wanip));
        else
                netsnmp_set_request_error(reqinfo, requests,SNMP_ERR_NOACCESS);
        break;
    case MODE_SET_RESERVE2:
        break;
    case MODE_SET_FREE:
        break;
    case MODE_SET_ACTION:
        wanip.s_addr = *((long *)requests->requestvb->val.string);
        if(strcmp(inet_ntoa(wanip),"NULL") == 0)
                netsnmp_set_request_error(reqinfo, requests,SNMP_ERR_WRONGVALUE);
        if(check_illegal_ip(inet_ntoa(wanip)) == -1)
                netsnmp_set_request_error(reqinfo, requests,SNMP_ERR_WRONGVALUE);
        else
                strcpy(temp_wanip,inet_ntoa(wanip));
        break;
    case MODE_SET_COMMIT:
        break;
    case MODE_SET_UNDO:
        break;
    default:
        return SNMP_ERR_GENERR;
    }
    return SNMP_ERR_NOERROR;
	
}

int
handle_dlkEnterpriseWANSubnetMask(netsnmp_mib_handler *handler,
                                  netsnmp_handler_registration *reginfo,
                                  netsnmp_agent_request_info *reqinfo,
                                  netsnmp_request_info *requests)
{
    static struct in_addr wan_mask;
    static char temp_mask[] = "255.255.255.0";
    static char mask_token_1[32] = "";
    static char mask_token_2[32] = "";
    static char mask_token_3[32] = "";
    static char mask_token_4[32] = "";
    switch (reqinfo->mode) {
    case MODE_GET:
        inet_aton(temp_mask,&wan_mask);
        snmp_set_var_typed_value(requests->requestvb, ASN_IPADDRESS,(u_char *)&wan_mask.s_addr,sizeof(long));
        break;
    case MODE_SET_RESERVE1:
        if(requests->requestvb->type != ASN_IPADDRESS)
                netsnmp_set_request_error(reqinfo, requests,SNMP_ERR_WRONGTYPE);
        if(wan_connected_mode == 1)
                memset(&wan_mask,0,sizeof(wan_mask));
        else
                netsnmp_set_request_error(reqinfo, requests,SNMP_ERR_NOACCESS);
        break;
    case MODE_SET_RESERVE2:
        break;
    case MODE_SET_FREE:
        break;
    case MODE_SET_ACTION:
        wan_mask.s_addr = *((long *)requests->requestvb->val.string);
        if(strcmp(inet_ntoa(wan_mask),"NULL") == 0)
                netsnmp_set_request_error(reqinfo, requests,SNMP_ERR_WRONGVALUE);
	strcpy(mask_token_1,strtok((inet_ntoa(wan_mask)),"."));
	strcpy(mask_token_2,strtok((NULL),"."));
	strcpy(mask_token_3,strtok((NULL),"."));
	strcpy(mask_token_4,strtok((NULL),"."));
	if(!(netmask_check(inet_ntoa(wan_mask),mask_token_1,mask_token_2,mask_token_3,mask_token_4)))
                netsnmp_set_request_error(reqinfo, requests,SNMP_ERR_WRONGVALUE);
        else
		strcpy(temp_mask,inet_ntoa(wan_mask));
        break;
    case MODE_SET_COMMIT:
        break;
    case MODE_SET_UNDO:
        break;
    default:
        return SNMP_ERR_GENERR;
    }
    return SNMP_ERR_NOERROR;
}

int
handle_dlkEnterpriseWANISPGateway(netsnmp_mib_handler *handler,
                                  netsnmp_handler_registration *reginfo,
                                  netsnmp_agent_request_info *reqinfo,
                                  netsnmp_request_info *requests)
{
    static struct in_addr wan_isp;
    static char temp_isp[] = "168.95.0.1";

    switch (reqinfo->mode) {
    case MODE_GET:
        inet_aton(temp_isp,&wan_isp);
        snmp_set_var_typed_value(requests->requestvb, ASN_IPADDRESS,(u_char *)&wan_isp.s_addr,sizeof(long));
        break;
    case MODE_SET_RESERVE1:
        if(requests->requestvb->type != ASN_IPADDRESS)
                netsnmp_set_request_error(reqinfo, requests,SNMP_ERR_WRONGTYPE);
        if(wan_connected_mode == 1)
                memset(&wan_isp,0,sizeof(wan_isp));
        else
                netsnmp_set_request_error(reqinfo, requests,SNMP_ERR_NOACCESS);
        break;
    case MODE_SET_RESERVE2:
        break;
    case MODE_SET_FREE:
        break;
    case MODE_SET_ACTION:
        wan_isp.s_addr = *((long *)requests->requestvb->val.string);
        if(strcmp(inet_ntoa(wan_isp),"NULL") == 0)
                netsnmp_set_request_error(reqinfo, requests,SNMP_ERR_WRONGVALUE);
        if(check_illegal_ip(inet_ntoa(wan_isp)) == -1)
                netsnmp_set_request_error(reqinfo, requests,SNMP_ERR_WRONGVALUE);
        else
                strcpy(temp_isp,inet_ntoa(wan_isp));
        break;
    case MODE_SET_COMMIT:
        break;
    case MODE_SET_UNDO:
        break;
    default:
        return SNMP_ERR_GENERR;
    }
    return SNMP_ERR_NOERROR;

}

int
handle_enterpriseUPNP(netsnmp_mib_handler *handler,
                      netsnmp_handler_registration *reginfo,
                      netsnmp_agent_request_info *reqinfo,
                      netsnmp_request_info *requests)
{
    static U_INT temp_upnp;
    int check_flag_upnp;
    switch (reqinfo->mode) {
    case MODE_GET:
	snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
                                 (u_char *)&advance_upnp,sizeof(U_INT));
        break;
    case MODE_SET_RESERVE1:
	if (requests->requestvb->val_len == 0)
                return SNMP_ERR_GENERR;
	temp_upnp = *((long *)requests->requestvb->val.integer);
        if(requests->requestvb->type != ASN_INTEGER)
                netsnmp_set_request_error(reqinfo, requests,SNMP_ERR_WRONGTYPE);
        if(temp_upnp == 0 || temp_upnp == 1)
                check_flag_upnp = 0;
        else
                check_flag_upnp = 1;
        if(check_flag_upnp)
                netsnmp_set_request_error(reqinfo, requests,SNMP_ERR_WRONGVALUE);
	break;
    case MODE_SET_RESERVE2:
        break;
    case MODE_SET_FREE:
        break;
    case MODE_SET_ACTION:
	if(temp_upnp)
	{
		printf("enable upnp\n");
		advance_upnp = temp_upnp;
	}
	else
		advance_upnp = 0;
        break;
    case MODE_SET_COMMIT:
        break;
    case MODE_SET_UNDO:
        break;
    default:
        return SNMP_ERR_GENERR;
    }
    return SNMP_ERR_NOERROR;
}

int
handle_enterpriseWANPingRespond(netsnmp_mib_handler *handler,
                      		netsnmp_handler_registration *reginfo,
                      		netsnmp_agent_request_info *reqinfo,
                      		netsnmp_request_info *requests)
{
    static U_INT temp_ping;
    int check_flag_ping;
    switch (reqinfo->mode) {
    case MODE_GET:
        snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
                                 (u_char *)&advance_ping_respond,sizeof(U_INT));
        break;
    case MODE_SET_RESERVE1:
	if (requests->requestvb->val_len == 0)
                return SNMP_ERR_GENERR;
        temp_ping = *((long *)requests->requestvb->val.integer);
        if(requests->requestvb->type != ASN_INTEGER)
                netsnmp_set_request_error(reqinfo, requests,SNMP_ERR_WRONGTYPE);
        if(temp_ping == 0 || temp_ping == 1)
                check_flag_ping = 0;
        else
                check_flag_ping = 1;
        if(check_flag_ping)
                netsnmp_set_request_error(reqinfo, requests,SNMP_ERR_WRONGVALUE);
        break;
    case MODE_SET_RESERVE2:
        break;
    case MODE_SET_FREE:
        break;
    case MODE_SET_ACTION:
        if(temp_ping)
        {
                printf("enable wan ping respond\n");
                advance_ping_respond = temp_ping;
        }
        else
                advance_ping_respond = 0;
	break;
    case MODE_SET_COMMIT:
        break;
    case MODE_SET_UNDO:
        break;
    default:
        return SNMP_ERR_GENERR;
    }
    return SNMP_ERR_NOERROR;
}

int
handle_enterpriseMulticastStreams(netsnmp_mib_handler *handler,
                                  netsnmp_handler_registration *reginfo,
                                  netsnmp_agent_request_info *reqinfo,
                                  netsnmp_request_info *requests)
{
    static U_INT temp_multicast;
    int check_flag_multicast;
    switch (reqinfo->mode) {
    case MODE_GET:
        snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
                                 (u_char *)&advance_multicast,sizeof(U_INT));
        break;
    case MODE_SET_RESERVE1:
	if (requests->requestvb->val_len == 0)
                return SNMP_ERR_GENERR;
        temp_multicast = *((long *)requests->requestvb->val.integer);
        if(requests->requestvb->type != ASN_INTEGER)
                netsnmp_set_request_error(reqinfo, requests,SNMP_ERR_WRONGTYPE);
        if(temp_multicast == 0 || temp_multicast == 1)
                check_flag_multicast = 0;
        else
                check_flag_multicast = 1;
        if(check_flag_multicast)
                netsnmp_set_request_error(reqinfo, requests,SNMP_ERR_WRONGVALUE);
        break;
    case MODE_SET_RESERVE2:
        break;
    case MODE_SET_FREE:
        break;
    case MODE_SET_ACTION:
        if(temp_multicast)
        {
                printf("enable multicast\n");
                advance_multicast = temp_multicast;
        }
        else
                advance_multicast = 0;
        break;
    case MODE_SET_COMMIT:
        break;
    case MODE_SET_UNDO:
        break;
    default:
        return SNMP_ERR_GENERR;
    }
    return SNMP_ERR_NOERROR;
}

int
handle_enterpriseDDNS(netsnmp_mib_handler *handler,
                      netsnmp_handler_registration *reginfo,
                      netsnmp_agent_request_info *reqinfo,
                      netsnmp_request_info *requests)
{
    static U_INT temp_ddns;
    int check_flag_ddns;
    switch (reqinfo->mode) {
    case MODE_GET:
        snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
                                 (u_char *)&advance_ddns,sizeof(U_INT));
        break;
    case MODE_SET_RESERVE1:
	if (requests->requestvb->val_len == 0)
                return SNMP_ERR_GENERR;
        temp_ddns = *((long *)requests->requestvb->val.integer);
        if(requests->requestvb->type != ASN_INTEGER)
                netsnmp_set_request_error(reqinfo, requests,SNMP_ERR_WRONGTYPE);
        if(temp_ddns == 0 || temp_ddns == 1)
                check_flag_ddns = 0;
        else
                check_flag_ddns = 1;
        if(check_flag_ddns)
                netsnmp_set_request_error(reqinfo, requests,SNMP_ERR_WRONGVALUE);
        break;
    case MODE_SET_RESERVE2:
        break;
    case MODE_SET_FREE:
        break;
    case MODE_SET_ACTION:
        if(temp_ddns){
                /*if we got broad, this will replace real "enable admin" function*/
                printf("enable DDNS\n");
                advance_ddns = temp_ddns;
        }
        else
                advance_ddns = 0;
        break;
    case MODE_SET_COMMIT:
        break;
    case MODE_SET_UNDO:
        break;
    default:
        return SNMP_ERR_GENERR;
    }
   return SNMP_ERR_NOERROR;

}

int
handle_enterpriseServerAddress(netsnmp_mib_handler *handler,
                      	       netsnmp_handler_registration *reginfo,
                               netsnmp_agent_request_info *reqinfo,
                               netsnmp_request_info *requests)
{
    static U_INT temp_server_address;

    switch (reqinfo->mode) {
    case MODE_GET:
        snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
                                 (u_char *)&advance_server_address,sizeof(U_INT));
        break;
    case MODE_SET_RESERVE1:
	if (requests->requestvb->val_len == 0)
                return SNMP_ERR_GENERR;
        if(advance_ddns == 0)
                netsnmp_set_request_error(reqinfo, requests,SNMP_ERR_NOACCESS);
        break;
    case MODE_SET_RESERVE2:
        break;
    case MODE_SET_FREE:
        break;
    case MODE_SET_ACTION:
        temp_server_address = *((long *)requests->requestvb->val.integer);
        if(requests->requestvb->type != ASN_INTEGER)
                netsnmp_set_request_error(reqinfo, requests,SNMP_ERR_WRONGTYPE);
        if(temp_server_address < 0 || temp_server_address > 2)
                netsnmp_set_request_error(reqinfo, requests,SNMP_ERR_WRONGVALUE);
        else
               advance_server_address = temp_server_address;
        /*if we got broad, this will replace real "console timeout" function*/
        printf("select DDNS server\n");
        break;
    case MODE_SET_COMMIT:
        break;
    case MODE_SET_UNDO:
        break;
    default:
        return SNMP_ERR_GENERR;
    }
    return SNMP_ERR_NOERROR;

}

int
handle_enterpriseHostName(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                      	  netsnmp_agent_request_info *reqinfo,
                          netsnmp_request_info *requests)
{
    static char temp_host_name[1024];
    static char advance_host_name[128] = "test.no-ip.com";
    switch (reqinfo->mode) {
    case MODE_GET:
        snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,
                                 (u_char *)&advance_host_name,strlen(advance_host_name));
        break;
    case MODE_SET_RESERVE1:
        if(advance_ddns == 0)
                netsnmp_set_request_error(reqinfo, requests,SNMP_ERR_NOACCESS);
	if(requests->requestvb->type != ASN_OCTET_STR)
                netsnmp_set_request_error(reqinfo, requests,SNMP_ERR_WRONGTYPE);
        else
                memset(temp_host_name,0,sizeof(temp_host_name));
        if(requests->requestvb->val_len == 0)
                netsnmp_set_request_error(reqinfo, requests,SNMP_ERR_WRONGVALUE);
        else
                memcpy(temp_host_name,requests->requestvb->val.string,requests->requestvb->val_len);
        if((strlen(temp_host_name) > 128) || (strcmp(temp_host_name,"NULL") == 0) || (strcmp(temp_host_name,"") == 0))
                netsnmp_set_request_error(reqinfo, requests,SNMP_ERR_WRONGVALUE);
    case MODE_SET_RESERVE2:
        break;
    case MODE_SET_FREE:
        break;
    case MODE_SET_ACTION:
        memset(advance_host_name,0,sizeof(advance_host_name));
        memcpy(advance_host_name,temp_host_name,strlen(temp_host_name));
        break;
    case MODE_SET_COMMIT:
        break;
    case MODE_SET_UNDO:
        break;
    default:
        return SNMP_ERR_GENERR;
    }
    return SNMP_ERR_NOERROR;

}

int
handle_enterpriseUserName(netsnmp_mib_handler *handler,
                      	  netsnmp_handler_registration *reginfo,
                      	  netsnmp_agent_request_info *reqinfo,
                      	  netsnmp_request_info *requests)
{
    static char temp_user_name[1024];
    static char advance_user_name[128] = " ";
    switch (reqinfo->mode) {
    case MODE_GET:
        snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,
                                 (u_char *)&advance_user_name,strlen(advance_user_name));
        break;
    case MODE_SET_RESERVE1:
	if(advance_ddns == 0)
                netsnmp_set_request_error(reqinfo, requests,SNMP_ERR_NOACCESS);
        if(requests->requestvb->type != ASN_OCTET_STR)
                netsnmp_set_request_error(reqinfo, requests,SNMP_ERR_WRONGTYPE);
        else
                memset(temp_user_name,0,sizeof(temp_user_name));
        if(requests->requestvb->val_len == 0)
                netsnmp_set_request_error(reqinfo, requests,SNMP_ERR_WRONGVALUE);
        else
                memcpy(temp_user_name,requests->requestvb->val.string,requests->requestvb->val_len);
        if((strlen(temp_user_name) > 128) || (strcmp(temp_user_name,"NULL") == 0) || (strcmp(temp_user_name,"") == 0))
                netsnmp_set_request_error(reqinfo, requests,SNMP_ERR_WRONGVALUE);
    case MODE_SET_RESERVE2:
        break;
    case MODE_SET_FREE:
        break;
    case MODE_SET_ACTION:
        memset(advance_user_name,0,sizeof(advance_user_name));
        memcpy(advance_user_name,temp_user_name,strlen(temp_user_name));
        break;
    case MODE_SET_COMMIT:
        break;
    case MODE_SET_UNDO:
        break;
    default:
        return SNMP_ERR_GENERR;
    }
    return SNMP_ERR_NOERROR;

}

int
handle_enterprisePassword(netsnmp_mib_handler *handler,
                      	  netsnmp_handler_registration *reginfo,
                      	  netsnmp_agent_request_info *reqinfo,
                      	  netsnmp_request_info *requests)
{
    static char temp_password_name[1024];
    static char advance_password_name[128] = " ";
    switch (reqinfo->mode) {
    case MODE_GET:
        snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,
                                 (u_char *)&advance_password_name,strlen(advance_password_name));
        break;
    case MODE_SET_RESERVE1:
	if(advance_ddns == 0)
                netsnmp_set_request_error(reqinfo, requests,SNMP_ERR_NOACCESS);
        if(requests->requestvb->type != ASN_OCTET_STR)
                netsnmp_set_request_error(reqinfo, requests,SNMP_ERR_WRONGTYPE);
        else
                memset(temp_password_name,0,sizeof(temp_password_name));
        if(requests->requestvb->val_len == 0)
                netsnmp_set_request_error(reqinfo, requests,SNMP_ERR_WRONGVALUE);
        else
                memcpy(temp_password_name,requests->requestvb->val.string,requests->requestvb->val_len);
        if((strlen(temp_password_name) > 128) || (strcmp(temp_password_name,"NULL") == 0) || (strcmp(temp_password_name,"") == 0))
                netsnmp_set_request_error(reqinfo, requests,SNMP_ERR_WRONGVALUE);
    case MODE_SET_RESERVE2:
        break;
    case MODE_SET_FREE:
        break;
    case MODE_SET_ACTION:
        memset(advance_password_name,0,sizeof(advance_password_name));
        memcpy(advance_password_name,temp_password_name,strlen(temp_password_name));
        break;
    case MODE_SET_COMMIT:
        break;
    case MODE_SET_UNDO:
        break;
    default:
        return SNMP_ERR_GENERR;
    }
    return SNMP_ERR_NOERROR;

}

int
handle_enterprisePPTPPassThrough(netsnmp_mib_handler *handler,
                                 netsnmp_handler_registration *reginfo,
                                 netsnmp_agent_request_info *reqinfo,
                                 netsnmp_request_info *requests)
{
    static U_INT temp_pptp_passthrough;
    int check_flag_pptp_passthrough;
    switch (reqinfo->mode) {
    case MODE_GET:
        snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
                                 (u_char *)&advance_pptp_passthrough,sizeof(U_INT));
        break;
    case MODE_SET_RESERVE1:
	if (requests->requestvb->val_len == 0)
                return SNMP_ERR_GENERR;
        temp_pptp_passthrough = *((long *)requests->requestvb->val.integer);
        if(requests->requestvb->type != ASN_INTEGER)
                netsnmp_set_request_error(reqinfo, requests,SNMP_ERR_WRONGTYPE);
        if(temp_pptp_passthrough == 0 || temp_pptp_passthrough == 1)
                check_flag_pptp_passthrough = 0;
        else
                check_flag_pptp_passthrough = 1;
        if(check_flag_pptp_passthrough)
                netsnmp_set_request_error(reqinfo, requests,SNMP_ERR_WRONGVALUE);
        break;
    case MODE_SET_RESERVE2:
        break;
    case MODE_SET_FREE:
        break;
    case MODE_SET_ACTION:
        if(temp_pptp_passthrough){
                /*if we got broad, this will replace real "enable admin" function*/
                printf("enable pptp passthrough\n");
                advance_pptp_passthrough = temp_pptp_passthrough;
        }
        else
                advance_pptp_passthrough = 0;
        break;
    case MODE_SET_COMMIT:
        break;
    case MODE_SET_UNDO:
        break;
    default:
        return SNMP_ERR_GENERR;
    }
   return SNMP_ERR_NOERROR;

}





int
handle_enterpriseL2TPPassThrough(netsnmp_mib_handler *handler,
                                 netsnmp_handler_registration *reginfo,
                                 netsnmp_agent_request_info *reqinfo,
                                 netsnmp_request_info *requests)
{
    static U_INT temp_l2tp_passthrough;
    int check_flag_l2tp_passthrough;
    switch (reqinfo->mode) {
    case MODE_GET:
        snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
                                 (u_char *)&advance_l2tp_passthrough,sizeof(U_INT));
        break;
    case MODE_SET_RESERVE1:
	if (requests->requestvb->val_len == 0)
                return SNMP_ERR_GENERR;
        temp_l2tp_passthrough = *((long *)requests->requestvb->val.integer);
        if(requests->requestvb->type != ASN_INTEGER)
                netsnmp_set_request_error(reqinfo, requests,SNMP_ERR_WRONGTYPE);
        if(temp_l2tp_passthrough == 0 || temp_l2tp_passthrough == 1)
                check_flag_l2tp_passthrough = 0;
        else
                check_flag_l2tp_passthrough = 1;
        if(check_flag_l2tp_passthrough)
                netsnmp_set_request_error(reqinfo, requests,SNMP_ERR_WRONGVALUE);
        break;
    case MODE_SET_RESERVE2:
        break;
    case MODE_SET_FREE:
        break;
    case MODE_SET_ACTION:
        if(temp_l2tp_passthrough){
                /*if we got broad, this will replace real "enable admin" function*/
                printf("enable l2tp passthrough\n");
                advance_l2tp_passthrough = temp_l2tp_passthrough;
        }
        else
                advance_l2tp_passthrough = 0;
        break;
    case MODE_SET_COMMIT:
        break;
    case MODE_SET_UNDO:
        break;
    default:
        return SNMP_ERR_GENERR;
    }
   return SNMP_ERR_NOERROR;

}

int
handle_enterpriseIPSECPassThrough(netsnmp_mib_handler *handler,
                                  netsnmp_handler_registration *reginfo,
                                  netsnmp_agent_request_info *reqinfo,
                                  netsnmp_request_info *requests)
{
    static U_INT temp_ipsec_passthrough;
    int check_flag_ipsec_passthrough;
    switch (reqinfo->mode) {
    case MODE_GET:
        snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
                                 (u_char *)&advance_ipsec_passthrough,sizeof(U_INT));
        break;
    case MODE_SET_RESERVE1:
	if (requests->requestvb->val_len == 0)
                return SNMP_ERR_GENERR;
        temp_ipsec_passthrough = *((long *)requests->requestvb->val.integer);
        if(requests->requestvb->type != ASN_INTEGER)
                netsnmp_set_request_error(reqinfo, requests,SNMP_ERR_WRONGTYPE);
        if(temp_ipsec_passthrough == 0 || temp_ipsec_passthrough == 1)
                check_flag_ipsec_passthrough = 0;
        else
                check_flag_ipsec_passthrough = 1;
        if(check_flag_ipsec_passthrough)
                netsnmp_set_request_error(reqinfo, requests,SNMP_ERR_WRONGVALUE);
        break;
    case MODE_SET_RESERVE2:
        break;
    case MODE_SET_FREE:
        break;
    case MODE_SET_ACTION:
        if(temp_ipsec_passthrough){
                /*if we got broad, this will replace real "enable admin" function*/
                printf("enable l2tp passthrough\n");
                advance_ipsec_passthrough = temp_ipsec_passthrough;
        }
        else
                advance_ipsec_passthrough = 0;
        break;
    case MODE_SET_COMMIT:
        break;
    case MODE_SET_UNDO:
        break;
    default:
        return SNMP_ERR_GENERR;
    }
   return SNMP_ERR_NOERROR;

}

int
handle_dlkEnterpriseLANIPAddress(netsnmp_mib_handler *handler,
                                 netsnmp_handler_registration *reginfo,
                                 netsnmp_agent_request_info *reqinfo,
                                 netsnmp_request_info *requests)
{
    static struct in_addr lanip;
    static char temp_lanip[] = "192.168.0.1";

    switch (reqinfo->mode) {
    case MODE_GET:
        inet_aton(temp_lanip,&lanip);
        snmp_set_var_typed_value(requests->requestvb, ASN_IPADDRESS,(u_char *)&lanip.s_addr,sizeof(long));
        break;
    case MODE_SET_RESERVE1:
        if(requests->requestvb->type != ASN_IPADDRESS)
                netsnmp_set_request_error(reqinfo, requests,SNMP_ERR_WRONGTYPE);
	memset(&lanip,0,sizeof(lanip));
        break;
    case MODE_SET_RESERVE2:
        break;
    case MODE_SET_FREE:
        break;
    case MODE_SET_ACTION:
        lanip.s_addr = *((long *)requests->requestvb->val.string);
        if(strcmp(inet_ntoa(lanip),"NULL") == 0)
                netsnmp_set_request_error(reqinfo, requests,SNMP_ERR_WRONGVALUE);
        if(check_illegal_ip(inet_ntoa(lanip)) == -1)
                netsnmp_set_request_error(reqinfo, requests,SNMP_ERR_WRONGVALUE);
        else
                strcpy(temp_lanip,inet_ntoa(lanip));
        break;
    case MODE_SET_COMMIT:
        break;
    case MODE_SET_UNDO:
        break;
    default:
        return SNMP_ERR_GENERR;
    }
    return SNMP_ERR_NOERROR;

}

int
handle_dlkEnterpriseLANSubnetMask(netsnmp_mib_handler *handler,
                                  netsnmp_handler_registration *reginfo,
                                  netsnmp_agent_request_info *reqinfo,
                                  netsnmp_request_info *requests)
{
    static struct in_addr lan_mask;
    static char temp_mask_lan[] = "255.255.255.0";
    static char mask_token_1_lan[32] = "";
    static char mask_token_2_lan[32] = "";
    static char mask_token_3_lan[32] = "";
    static char mask_token_4_lan[32] = "";
    switch (reqinfo->mode) {
    case MODE_GET:
        inet_aton(temp_mask_lan,&lan_mask);
        snmp_set_var_typed_value(requests->requestvb, ASN_IPADDRESS,(u_char *)&lan_mask.s_addr,sizeof(long));
        break;
    case MODE_SET_RESERVE1:
        if(requests->requestvb->type != ASN_IPADDRESS)
                netsnmp_set_request_error(reqinfo, requests,SNMP_ERR_WRONGTYPE);
	memset(&lan_mask,0,sizeof(lan_mask));
        break;
    case MODE_SET_RESERVE2:
        break;
    case MODE_SET_FREE:
        break;
    case MODE_SET_ACTION:
        lan_mask.s_addr = *((long *)requests->requestvb->val.string);
        if(strcmp(inet_ntoa(lan_mask),"NULL") == 0)
                netsnmp_set_request_error(reqinfo, requests,SNMP_ERR_WRONGVALUE);
        strcpy(mask_token_1_lan,strtok((inet_ntoa(lan_mask)),"."));
        strcpy(mask_token_2_lan,strtok((NULL),"."));
        strcpy(mask_token_3_lan,strtok((NULL),"."));
        strcpy(mask_token_4_lan,strtok((NULL),"."));
        if(!(netmask_check(inet_ntoa(lan_mask),mask_token_1_lan,mask_token_2_lan,mask_token_3_lan,mask_token_4_lan)))
                netsnmp_set_request_error(reqinfo, requests,SNMP_ERR_WRONGVALUE);
        else
                strcpy(temp_mask_lan,inet_ntoa(lan_mask));
        break;
    case MODE_SET_COMMIT:
        break;
    case MODE_SET_UNDO:
        break;
    default:
        return SNMP_ERR_GENERR;
    }
    return SNMP_ERR_NOERROR;
}

int
handle_dlkEnterpriseLANDomainName(netsnmp_mib_handler *handler,
                                  netsnmp_handler_registration *reginfo,
                                  netsnmp_agent_request_info *reqinfo,
                                  netsnmp_request_info *requests)
{
    static char lan_domain_name[64] = "dlink";
    static char temp_domain_name[64];
    switch (reqinfo->mode) {
    case MODE_GET:
        snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,
                                 (u_char *)&lan_domain_name,strlen(lan_domain_name));
        break;
    case MODE_SET_RESERVE1:
        if(requests->requestvb->type != ASN_OCTET_STR)
                netsnmp_set_request_error(reqinfo, requests,SNMP_ERR_WRONGTYPE);
        else
                memset(temp_domain_name,0,sizeof(temp_domain_name));
        if(requests->requestvb->val_len == 0)
                netsnmp_set_request_error(reqinfo, requests,SNMP_ERR_WRONGVALUE);
        else
                memcpy(temp_domain_name,requests->requestvb->val.string,requests->requestvb->val_len);
        if((strlen(temp_domain_name) > 64) || (strcmp(temp_domain_name,"NULL") == 0) || (strcmp(temp_domain_name,"") == 0))
                netsnmp_set_request_error(reqinfo, requests,SNMP_ERR_WRONGVALUE);

        break;
    case MODE_SET_RESERVE2:
        break;
    case MODE_SET_FREE:
        break;
    case MODE_SET_ACTION:
        memset(lan_domain_name,0,sizeof(lan_domain_name));
        memcpy(lan_domain_name,temp_domain_name,strlen(temp_domain_name));
        break;
    case MODE_SET_COMMIT:
        break;
    case MODE_SET_UNDO:
        break;
    default:
        return SNMP_ERR_GENERR;
    }
    return SNMP_ERR_NOERROR;
}




int
handle_dlkEnterpriseLANDNSRelay(netsnmp_mib_handler *handler,
                                netsnmp_handler_registration *reginfo,
                                netsnmp_agent_request_info *reqinfo,
                                netsnmp_request_info *requests)
{
    static U_INT temp_dns_relay;
    int check_flag_dns_relay;
    switch (reqinfo->mode) {
    case MODE_GET:
        snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
                                 (u_char *)&lan_dns_relay,sizeof(U_INT));
        break;
    case MODE_SET_RESERVE1:
	if (requests->requestvb->val_len == 0)
                return SNMP_ERR_GENERR;
        temp_dns_relay = *((long *)requests->requestvb->val.integer);
        if(requests->requestvb->type != ASN_INTEGER)
                netsnmp_set_request_error(reqinfo, requests,SNMP_ERR_WRONGTYPE);
        if(temp_dns_relay == 0 || temp_dns_relay == 1)
                check_flag_dns_relay = 0;
        else
                check_flag_dns_relay = 1;
        if(check_flag_dns_relay)
                netsnmp_set_request_error(reqinfo, requests,SNMP_ERR_WRONGVALUE);
        break;
    case MODE_SET_RESERVE2:
        break;
    case MODE_SET_FREE:
        break;
    case MODE_SET_ACTION:
        if(temp_dns_relay){
                /*if we got broad, this will replace real "enable admin" function*/
                printf("enable dns_relay\n");
                lan_dns_relay = temp_dns_relay;
        }
        else
                lan_dns_relay = 0;
        break;
    case MODE_SET_COMMIT:
        break;
    case MODE_SET_UNDO:
        break;
    default:
        return SNMP_ERR_GENERR;
    }
   return SNMP_ERR_NOERROR;

}

int
handle_dlkWANTxFrameCount(netsnmp_mib_handler *handler,
                       netsnmp_handler_registration *reginfo,
                       netsnmp_agent_request_info *reqinfo,
                       netsnmp_request_info *requests)
{
    switch (reqinfo->mode) {
    case MODE_GET:
        snmp_set_var_typed_value(requests->requestvb, ASN_COUNTER,
                                 (u_char *)&wan_tx_frame_count,sizeof(wan_tx_frame_count));
        break;
    default:
        return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
handle_dlkWANTxMulticastFrameCount(netsnmp_mib_handler *handler,
                       		netsnmp_handler_registration *reginfo,
                       		netsnmp_agent_request_info *reqinfo,
                       		netsnmp_request_info *requests)
{
    switch (reqinfo->mode) {
    case MODE_GET:
        snmp_set_var_typed_value(requests->requestvb, ASN_COUNTER,
                                 (u_char *)&wan_tx_multicast_frame_count,sizeof(wan_tx_multicast_frame_count));
        break;
    default:
        return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
handle_dlkWANTxErrorFrameCount(netsnmp_mib_handler *handler,
                            netsnmp_handler_registration *reginfo,
                            netsnmp_agent_request_info *reqinfo,
                            netsnmp_request_info *requests)
{
    switch (reqinfo->mode) {
    case MODE_GET:
        snmp_set_var_typed_value(requests->requestvb, ASN_COUNTER,
                                 (u_char *)&wan_tx_error_frame_count,sizeof(wan_tx_error_frame_count));
        break;
    default:
        return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
handle_dlkWANRxFrameCount(netsnmp_mib_handler *handler,
                       netsnmp_handler_registration *reginfo,
                       netsnmp_agent_request_info *reqinfo,
                       netsnmp_request_info *requests)
{
    switch (reqinfo->mode) {
    case MODE_GET:
        snmp_set_var_typed_value(requests->requestvb, ASN_COUNTER,
                                 (u_char *)&wan_rx_frame_count,sizeof(wan_rx_frame_count));
        break;
    default:
        return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
handle_dlkWANRxMulticastFrameCount(netsnmp_mib_handler *handler,
                                netsnmp_handler_registration *reginfo,
                                netsnmp_agent_request_info *reqinfo,
                                netsnmp_request_info *requests)
{
    switch (reqinfo->mode) {
    case MODE_GET:
        snmp_set_var_typed_value(requests->requestvb, ASN_COUNTER,
                                 (u_char *)&wan_rx_multicast_frame_count,sizeof(wan_rx_multicast_frame_count));
        break;
    default:
        return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
handle_dlkWANRxErrorFrameCount(netsnmp_mib_handler *handler,
                            netsnmp_handler_registration *reginfo,
                            netsnmp_agent_request_info *reqinfo,
                            netsnmp_request_info *requests)
{
    switch (reqinfo->mode) {
    case MODE_GET:
        snmp_set_var_typed_value(requests->requestvb, ASN_COUNTER,
                                 (u_char *)&wan_rx_error_frame_count,sizeof(wan_rx_error_frame_count));
        break;
    default:
        return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
handle_dlkLANTxFrameCount(netsnmp_mib_handler *handler,
                       netsnmp_handler_registration *reginfo,
                       netsnmp_agent_request_info *reqinfo,
                       netsnmp_request_info *requests)
{
    switch (reqinfo->mode) {
    case MODE_GET:
        snmp_set_var_typed_value(requests->requestvb, ASN_COUNTER,
                                 (u_char *)&lan_tx_frame_count,sizeof(lan_tx_frame_count));
        break;
    default:
        return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
handle_dlkLANTxMulticastFrameCount(netsnmp_mib_handler *handler,
                                netsnmp_handler_registration *reginfo,
                                netsnmp_agent_request_info *reqinfo,
                                netsnmp_request_info *requests)
{
    switch (reqinfo->mode) {
    case MODE_GET:
        snmp_set_var_typed_value(requests->requestvb, ASN_COUNTER,
                                 (u_char *)&lan_tx_multicast_frame_count,sizeof(lan_tx_multicast_frame_count));
        break;
    default:
        return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
handle_dlkLANTxErrorFrameCount(netsnmp_mib_handler *handler,
                            netsnmp_handler_registration *reginfo,
                            netsnmp_agent_request_info *reqinfo,
                            netsnmp_request_info *requests)
{
    switch (reqinfo->mode) {
    case MODE_GET:
        snmp_set_var_typed_value(requests->requestvb, ASN_COUNTER,
                                 (u_char *)&lan_tx_error_frame_count,sizeof(lan_tx_error_frame_count));
        break;
    default:
        return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
handle_dlkLANRxFrameCount(netsnmp_mib_handler *handler,
                       netsnmp_handler_registration *reginfo,
                       netsnmp_agent_request_info *reqinfo,
                       netsnmp_request_info *requests)
{
    switch (reqinfo->mode) {
    case MODE_GET:
        snmp_set_var_typed_value(requests->requestvb, ASN_COUNTER,
                                 (u_char *)&lan_rx_frame_count,sizeof(lan_rx_frame_count));
        break;
    default:
        return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
handle_dlkLANRxMulticastFrameCount(netsnmp_mib_handler *handler,
                                netsnmp_handler_registration *reginfo,
                                netsnmp_agent_request_info *reqinfo,
                                netsnmp_request_info *requests)
{
    switch (reqinfo->mode) {
    case MODE_GET:
        snmp_set_var_typed_value(requests->requestvb, ASN_COUNTER,
                                 (u_char *)&lan_rx_multicast_frame_count,sizeof(lan_rx_multicast_frame_count));
        break;
    default:
        return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
handle_dlkLANRxErrorFrameCount(netsnmp_mib_handler *handler,
                            netsnmp_handler_registration *reginfo,
                            netsnmp_agent_request_info *reqinfo,
                            netsnmp_request_info *requests)
{
    switch (reqinfo->mode) {
    case MODE_GET:
        snmp_set_var_typed_value(requests->requestvb, ASN_COUNTER,
                                 (u_char *)&lan_rx_error_frame_count,sizeof(lan_rx_error_frame_count));
        break;
    default:
        return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
handle_dlkEnterpriseDHCPService(netsnmp_mib_handler *handler,
                                netsnmp_handler_registration *reginfo,
                                netsnmp_agent_request_info *reqinfo,
                                netsnmp_request_info *requests)
{
    static U_INT temp_dhcp;
    int check_flag_dhcp;
    switch (reqinfo->mode) {
    case MODE_GET:
        snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
                                 (u_char *)&lan_dhcp,sizeof(U_INT));
        break;
    case MODE_SET_RESERVE1:
        if (requests->requestvb->val_len == 0)
                return SNMP_ERR_GENERR;
        temp_dhcp = *((long *)requests->requestvb->val.integer);
        if(requests->requestvb->type != ASN_INTEGER)
                netsnmp_set_request_error(reqinfo, requests,SNMP_ERR_WRONGTYPE);
        if(temp_dhcp == 0 || temp_dhcp == 1)
                check_flag_dhcp = 0;
        else
                check_flag_dhcp = 1;
        if(check_flag_dhcp)
                netsnmp_set_request_error(reqinfo, requests,SNMP_ERR_WRONGVALUE);
        break;
    case MODE_SET_RESERVE2:
        break;
    case MODE_SET_FREE:
        break;
    case MODE_SET_ACTION:
        if(temp_dhcp){
                /*if we got broad, this will replace real "enable admin" function*/
                printf("enable DHCPD\n");
                lan_dhcp = temp_dhcp;
        }
        else
                lan_dhcp = 0;
        break;
    case MODE_SET_COMMIT:
        break;
    case MODE_SET_UNDO:
        break;
    default:
        return SNMP_ERR_GENERR;
    }
   return SNMP_ERR_NOERROR;
}

int
handle_dlkEnterpriseDHCPStartIP(netsnmp_mib_handler *handler,
                                netsnmp_handler_registration *reginfo,
                                netsnmp_agent_request_info *reqinfo,
                                netsnmp_request_info *requests)
{
    static U_INT temp_dhcp_start_ip;
    int check_flag_dhcp_start_ip;
    switch (reqinfo->mode) {
    case MODE_GET:
        snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
                                 (u_char *)&lan_dhcp_start_ip,sizeof(U_INT));
        break;
    case MODE_SET_RESERVE1:
	if(lan_dhcp == 0)
		netsnmp_set_request_error(reqinfo, requests,SNMP_ERR_NOACCESS);
        if (requests->requestvb->val_len == 0)
                return SNMP_ERR_GENERR;
        temp_dhcp_start_ip = *((long *)requests->requestvb->val.integer);
        if(requests->requestvb->type != ASN_INTEGER)
                netsnmp_set_request_error(reqinfo, requests,SNMP_ERR_WRONGTYPE);
        if(temp_dhcp_start_ip < 1 || temp_dhcp_start_ip > 254 || (temp_dhcp_start_ip == lan_dhcp_end_ip))
                check_flag_dhcp_start_ip = 1;
        else
                check_flag_dhcp_start_ip = 0;
        if(check_flag_dhcp_start_ip)
                netsnmp_set_request_error(reqinfo, requests,SNMP_ERR_WRONGVALUE);
        break;
    case MODE_SET_RESERVE2:
        break;
    case MODE_SET_FREE:
        break;
    case MODE_SET_ACTION:
	/*if we got broad, this will replace real "enable admin" function*/
	printf("set start ip to DHCPD\n");
	lan_dhcp_start_ip = temp_dhcp_start_ip;
        break;
    case MODE_SET_COMMIT:
        break;
    case MODE_SET_UNDO:
        break;
    default:
        return SNMP_ERR_GENERR;
    }
   return SNMP_ERR_NOERROR;
}

int
handle_dlkEnterpriseDHCPEndIP(netsnmp_mib_handler *handler,
                              netsnmp_handler_registration *reginfo,
                              netsnmp_agent_request_info *reqinfo,
                              netsnmp_request_info *requests)
{
    static U_INT temp_dhcp_end_ip;
    int check_flag_dhcp_end_ip;
    switch (reqinfo->mode) {
    case MODE_GET:
        snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
                                 (u_char *)&lan_dhcp_end_ip,sizeof(U_INT));
        break;
    case MODE_SET_RESERVE1:
	if(lan_dhcp == 0)
                netsnmp_set_request_error(reqinfo, requests,SNMP_ERR_NOACCESS);
        if (requests->requestvb->val_len == 0)
                return SNMP_ERR_GENERR;
        temp_dhcp_end_ip = *((long *)requests->requestvb->val.integer);
        if(requests->requestvb->type != ASN_INTEGER)
                netsnmp_set_request_error(reqinfo, requests,SNMP_ERR_WRONGTYPE);
        if(temp_dhcp_end_ip < 1 || temp_dhcp_end_ip > 254 || (lan_dhcp_start_ip == temp_dhcp_end_ip))
                check_flag_dhcp_end_ip = 1;
        else
                check_flag_dhcp_end_ip = 0;
        if(check_flag_dhcp_end_ip)
                netsnmp_set_request_error(reqinfo, requests,SNMP_ERR_WRONGVALUE);
        break;
    case MODE_SET_RESERVE2:
        break;
    case MODE_SET_FREE:
        break;
    case MODE_SET_ACTION:
        /*if we got broad, this will replace real "enable admin" function*/
        printf("set end ip to DHCPD\n");
        lan_dhcp_end_ip = temp_dhcp_end_ip;
        break;
    case MODE_SET_COMMIT:
        break;
    case MODE_SET_UNDO:
        break;
    default:
        return SNMP_ERR_GENERR;
    }
   return SNMP_ERR_NOERROR;
}

int
handle_dlkEnterpriseDHCPLeaseTime(netsnmp_mib_handler *handler,
                                  netsnmp_handler_registration *reginfo,
                                  netsnmp_agent_request_info *reqinfo,
                                  netsnmp_request_info *requests)
{
    static U_INT temp_dhcp_lease_time;
   
    switch (reqinfo->mode) {
    case MODE_GET:
        snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
                                 (u_char *)&lan_dhcp_lease_time,sizeof(U_INT));
        break;
    case MODE_SET_RESERVE1:
	if(lan_dhcp == 0)
                netsnmp_set_request_error(reqinfo, requests,SNMP_ERR_NOACCESS);
        if (requests->requestvb->val_len == 0)
                return SNMP_ERR_GENERR;
        temp_dhcp_lease_time = *((long *)requests->requestvb->val.integer);
        if(requests->requestvb->type != ASN_INTEGER)
                netsnmp_set_request_error(reqinfo, requests,SNMP_ERR_WRONGTYPE);
        if(temp_dhcp_lease_time < 1 || temp_dhcp_lease_time > 4294967294 )
                netsnmp_set_request_error(reqinfo, requests,SNMP_ERR_WRONGVALUE);
        break;
    case MODE_SET_RESERVE2:
        break;
    case MODE_SET_FREE:
        break;
    case MODE_SET_ACTION:
        /*if we got broad, this will replace real "enable admin" function*/
        printf("set lease time to DHCPD\n");
        lan_dhcp_lease_time = temp_dhcp_lease_time;
        break;
    case MODE_SET_COMMIT:
        break;
    case MODE_SET_UNDO:
        break;
    default:
        return SNMP_ERR_GENERR;
    }
   return SNMP_ERR_NOERROR;
}

int
handle_dlkEnterpriseDHCPDomainName(netsnmp_mib_handler *handler,
                              	   netsnmp_handler_registration *reginfo,
                              	   netsnmp_agent_request_info *reqinfo,
                                   netsnmp_request_info *requests)
{
    static char lan_domain_name_dhcp[64] = "dlink";
    static char temp_domain_name_dhcp[64];
    switch (reqinfo->mode) {
    case MODE_GET:
        snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,
                                 (u_char *)&lan_domain_name_dhcp,strlen(lan_domain_name_dhcp));
        break;
    case MODE_SET_RESERVE1:
	if(lan_dhcp == 0)
                netsnmp_set_request_error(reqinfo, requests,SNMP_ERR_NOACCESS);
        if(requests->requestvb->type != ASN_OCTET_STR)
                netsnmp_set_request_error(reqinfo, requests,SNMP_ERR_WRONGTYPE);
        else
                memset(temp_domain_name_dhcp,0,sizeof(temp_domain_name_dhcp));
        if(requests->requestvb->val_len == 0)
                netsnmp_set_request_error(reqinfo, requests,SNMP_ERR_WRONGVALUE);
        else
                memcpy(temp_domain_name_dhcp,requests->requestvb->val.string,requests->requestvb->val_len);
        if((strlen(temp_domain_name_dhcp) > 64) || (strcmp(temp_domain_name_dhcp,"NULL") == 0) || (strcmp(temp_domain_name_dhcp,"") == 0))
                netsnmp_set_request_error(reqinfo, requests,SNMP_ERR_WRONGVALUE);

        break;
    case MODE_SET_RESERVE2:
        break;
    case MODE_SET_FREE:
        break;
    case MODE_SET_ACTION:
        memset(lan_domain_name_dhcp,0,sizeof(lan_domain_name_dhcp));
        memcpy(lan_domain_name_dhcp,temp_domain_name_dhcp,strlen(temp_domain_name_dhcp));
        break;
    case MODE_SET_COMMIT:
        break;
    case MODE_SET_UNDO:
        break;
    default:
        return SNMP_ERR_GENERR;
    }
    return SNMP_ERR_NOERROR;
}

int
handle_dlkEnterpriseDHCPDNSRelay(netsnmp_mib_handler *handler,
                                 netsnmp_handler_registration *reginfo,
                                 netsnmp_agent_request_info *reqinfo,
                                 netsnmp_request_info *requests)
{
    static U_INT temp_dns_relay_dhcp;
    int check_flag_dns_relay_dhcp;
    switch (reqinfo->mode) {
    case MODE_GET:
        snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
                                 (u_char *)&lan_dhcp_dns_relay,sizeof(U_INT));
        break;
    case MODE_SET_RESERVE1:
        if(lan_dhcp == 0)
                netsnmp_set_request_error(reqinfo, requests,SNMP_ERR_NOACCESS);
	if (requests->requestvb->val_len == 0)
                return SNMP_ERR_GENERR;
        temp_dns_relay_dhcp = *((long *)requests->requestvb->val.integer);
        if(requests->requestvb->type != ASN_INTEGER)
                netsnmp_set_request_error(reqinfo, requests,SNMP_ERR_WRONGTYPE);
        if(temp_dns_relay_dhcp == 0 || temp_dns_relay_dhcp == 1)
                check_flag_dns_relay_dhcp = 0;
        else
                check_flag_dns_relay_dhcp = 1;
        if(check_flag_dns_relay_dhcp)
                netsnmp_set_request_error(reqinfo, requests,SNMP_ERR_WRONGVALUE);
        break;
    case MODE_SET_RESERVE2:
        break;
    case MODE_SET_FREE:
        break;
    case MODE_SET_ACTION:
        if(temp_dns_relay_dhcp){
                /*if we got broad, this will replace real "enable admin" function*/
                printf("enable dns_relay for DHCPD\n");
                lan_dhcp_dns_relay = temp_dns_relay_dhcp;
        }
        else
                lan_dhcp_dns_relay = 0;
        break;
    case MODE_SET_COMMIT:
        break;
    case MODE_SET_UNDO:
        break;
    default:
        return SNMP_ERR_GENERR;
    }
   return SNMP_ERR_NOERROR;

}

int
handle_enterpriseNTPServerIP(netsnmp_mib_handler *handler,
                             netsnmp_handler_registration *reginfo,
                             netsnmp_agent_request_info *reqinfo,
                             netsnmp_request_info *requests)
{
    static struct in_addr ntp;
    static char temp_ntp_ip[] = "192.168.0.1";

    switch (reqinfo->mode) {
    case MODE_GET:
        inet_aton(temp_ntp_ip,&ntp);
        snmp_set_var_typed_value(requests->requestvb, ASN_IPADDRESS,(u_char *)&ntp.s_addr,sizeof(long));
        break;
    case MODE_SET_RESERVE1:
        if(requests->requestvb->type != ASN_IPADDRESS)
                netsnmp_set_request_error(reqinfo, requests,SNMP_ERR_WRONGTYPE);
        memset(&ntp,0,sizeof(ntp));
        break;
    case MODE_SET_RESERVE2:
        break;
    case MODE_SET_FREE:
        break;
    case MODE_SET_ACTION:
        ntp.s_addr = *((long *)requests->requestvb->val.string);
        if(strcmp(inet_ntoa(ntp),"NULL") == 0)
                netsnmp_set_request_error(reqinfo, requests,SNMP_ERR_WRONGVALUE);
        if(check_illegal_ip(inet_ntoa(ntp)) == -1)
                netsnmp_set_request_error(reqinfo, requests,SNMP_ERR_WRONGVALUE);
        else
                strcpy(temp_ntp_ip,inet_ntoa(ntp));
        break;
    case MODE_SET_COMMIT:
        break;
    case MODE_SET_UNDO:
        break;
    default:
        return SNMP_ERR_GENERR;
    }
    return SNMP_ERR_NOERROR;
}

int
handle_enterpriseNTPTimeZone(netsnmp_mib_handler *handler,
                             netsnmp_handler_registration *reginfo,
                             netsnmp_agent_request_info *reqinfo,
                             netsnmp_request_info *requests)
{
    static U_INT temp_ntp_time_zone;

    switch (reqinfo->mode) {
    case MODE_GET:
        snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
                                 (u_char *)&system_ntp_time_zone,sizeof(U_INT));
        break;
    case MODE_SET_RESERVE1:
        break;
    case MODE_SET_RESERVE2:
        break;
    case MODE_SET_FREE:
        break;
    case MODE_SET_ACTION:
        if (requests->requestvb->val_len == 0)
                return SNMP_ERR_GENERR;
        temp_ntp_time_zone = *((long *)requests->requestvb->val.integer);
        if(requests->requestvb->type != ASN_INTEGER)
                netsnmp_set_request_error(reqinfo, requests,SNMP_ERR_WRONGTYPE);
        if(temp_ntp_time_zone < 0 || temp_ntp_time_zone > 41)
                netsnmp_set_request_error(reqinfo, requests,SNMP_ERR_WRONGVALUE);
        else
                system_ntp_time_zone = temp_ntp_time_zone;
        /*if we got broad, this will replace real "console timeout" function*/
        printf("set ntp time zone function\n");
        break;
    case MODE_SET_COMMIT:
        break;
    case MODE_SET_UNDO:
        break;
    default:
        return SNMP_ERR_GENERR;
    }
    return SNMP_ERR_NOERROR;
}


int
handle_EnterpriseNTPDaylightSaving(netsnmp_mib_handler *handler,
                                   netsnmp_handler_registration *reginfo,
                                   netsnmp_agent_request_info *reqinfo,
                                   netsnmp_request_info *requests)
{
    static U_INT temp_ntp_daylight_saving;
    int check_flag_ntp_daylight_saving;
    switch (reqinfo->mode) {
    case MODE_GET:
        snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
                                 (u_char *)&system_ntp_daylight_saving,sizeof(U_INT));
        break;
    case MODE_SET_RESERVE1:
        if (requests->requestvb->val_len == 0)
                return SNMP_ERR_GENERR;
        temp_ntp_daylight_saving = *((long *)requests->requestvb->val.integer);
        if(requests->requestvb->type != ASN_INTEGER)
                netsnmp_set_request_error(reqinfo, requests,SNMP_ERR_WRONGTYPE);
        if(temp_ntp_daylight_saving == 0 || temp_ntp_daylight_saving == 1)
                check_flag_ntp_daylight_saving = 0;
        else
                check_flag_ntp_daylight_saving = 1;
        if(check_flag_ntp_daylight_saving)
                netsnmp_set_request_error(reqinfo, requests,SNMP_ERR_WRONGVALUE);
        break;
    case MODE_SET_RESERVE2:
        break;
    case MODE_SET_FREE:
        break;
    case MODE_SET_ACTION:
        if(temp_ntp_daylight_saving){
                /*if we got broad, this will replace real "enable admin" function*/
                printf("enable ntp daylight saving\n");
                system_ntp_daylight_saving = temp_ntp_daylight_saving;
        }
        else
                system_ntp_daylight_saving = 0;
        break;
    case MODE_SET_COMMIT:
        break;
    case MODE_SET_UNDO:
        break;
    default:
        return SNMP_ERR_GENERR;
    }
   return SNMP_ERR_NOERROR;
}

int
handle_enterpriseStartMonth(netsnmp_mib_handler *handler,
                            netsnmp_handler_registration *reginfo,
                            netsnmp_agent_request_info *reqinfo,
                            netsnmp_request_info *requests)
{
    static U_INT temp_ntp_start_month;

    switch (reqinfo->mode) {
    case MODE_GET:
        snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
                                 (u_char *)&system_ntp_start_month,sizeof(U_INT));
        break;
    case MODE_SET_RESERVE1:
        break;
    case MODE_SET_RESERVE2:
        break;
    case MODE_SET_FREE:
        break;
    case MODE_SET_ACTION:
	if(system_ntp_daylight_saving == 0)
		netsnmp_set_request_error(reqinfo, requests,SNMP_ERR_NOACCESS);
        if (requests->requestvb->val_len == 0)
                return SNMP_ERR_GENERR;
        temp_ntp_start_month = *((long *)requests->requestvb->val.integer);
        if(requests->requestvb->type != ASN_INTEGER)
                netsnmp_set_request_error(reqinfo, requests,SNMP_ERR_WRONGTYPE);
        if(temp_ntp_start_month > system_ntp_end_month)
        {
                netsnmp_set_request_error(reqinfo, requests,SNMP_ERR_WRONGVALUE);
                return SNMP_ERR_WRONGVALUE;
        }
	if(temp_ntp_start_month < 1 || temp_ntp_start_month > 12)
                netsnmp_set_request_error(reqinfo, requests,SNMP_ERR_WRONGVALUE);
        else
                system_ntp_start_month = temp_ntp_start_month;
        /*if we got broad, this will replace real "console timeout" function*/
        printf("set ntp month function\n");
        break;
    case MODE_SET_COMMIT:
        break;
    case MODE_SET_UNDO:
        break;
    default:
        return SNMP_ERR_GENERR;
    }
    return SNMP_ERR_NOERROR;
}

int
handle_enterpriseStartWeek(netsnmp_mib_handler *handler,
                           netsnmp_handler_registration *reginfo,
                           netsnmp_agent_request_info *reqinfo,
                           netsnmp_request_info *requests)
{
    static U_INT temp_ntp_start_week;

    switch (reqinfo->mode) {
    case MODE_GET:
        snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
                                 (u_char *)&system_ntp_start_week,sizeof(U_INT));
        break;
    case MODE_SET_RESERVE1:
        break;
    case MODE_SET_RESERVE2:
        break;
    case MODE_SET_FREE:
        break;
    case MODE_SET_ACTION:
        if(system_ntp_daylight_saving == 0)
                netsnmp_set_request_error(reqinfo, requests,SNMP_ERR_NOACCESS);
        if (requests->requestvb->val_len == 0)
                return SNMP_ERR_GENERR;
        temp_ntp_start_week = *((long *)requests->requestvb->val.integer);
        if(requests->requestvb->type != ASN_INTEGER)
                netsnmp_set_request_error(reqinfo, requests,SNMP_ERR_WRONGTYPE);
        if(system_ntp_start_month == system_ntp_end_month)
		if(temp_ntp_start_week > system_ntp_end_week)
                {
                        netsnmp_set_request_error(reqinfo, requests,SNMP_ERR_WRONGVALUE);
                        return SNMP_ERR_WRONGVALUE;
                }
	if(temp_ntp_start_week < 1 || temp_ntp_start_week > 5)
                netsnmp_set_request_error(reqinfo, requests,SNMP_ERR_WRONGVALUE);
        else
                system_ntp_start_week = temp_ntp_start_week;
        /*if we got broad, this will replace real "console timeout" function*/
        printf("set ntp week function\n");
        break;
    case MODE_SET_COMMIT:
        break;
    case MODE_SET_UNDO:
        break;
    default:
        return SNMP_ERR_GENERR;
    }
    return SNMP_ERR_NOERROR;
}

int
handle_enterpriseStartDayOfWeek(netsnmp_mib_handler *handler,
                           	netsnmp_handler_registration *reginfo,
                           	netsnmp_agent_request_info *reqinfo,
                           	netsnmp_request_info *requests)
{
    static U_INT temp_ntp_start_day;

    switch (reqinfo->mode) {
    case MODE_GET:
        snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
                                 (u_char *)&system_ntp_start_day,sizeof(U_INT));
        break;
    case MODE_SET_RESERVE1:
        break;
    case MODE_SET_RESERVE2:
        break;
    case MODE_SET_FREE:
        break;
    case MODE_SET_ACTION:
        if(system_ntp_daylight_saving == 0)
                netsnmp_set_request_error(reqinfo, requests,SNMP_ERR_NOACCESS);
        if (requests->requestvb->val_len == 0)
                return SNMP_ERR_GENERR;
        temp_ntp_start_day = *((long *)requests->requestvb->val.integer);
        if(requests->requestvb->type != ASN_INTEGER)
                netsnmp_set_request_error(reqinfo, requests,SNMP_ERR_WRONGTYPE);
        if((system_ntp_start_month == system_ntp_end_month) && (system_ntp_start_week == system_ntp_end_week))
                if(temp_ntp_start_day > system_ntp_end_day)
                {
                        netsnmp_set_request_error(reqinfo, requests,SNMP_ERR_WRONGVALUE);
                        return SNMP_ERR_WRONGVALUE;
                }
	if(temp_ntp_start_day < 1 || temp_ntp_start_day > 7)
                netsnmp_set_request_error(reqinfo, requests,SNMP_ERR_WRONGVALUE);
        else
                system_ntp_start_day = temp_ntp_start_day;
        /*if we got broad, this will replace real "console timeout" function*/
        printf("set ntp day function\n");
        break;
    case MODE_SET_COMMIT:
        break;
    case MODE_SET_UNDO:
        break;
    default:
        return SNMP_ERR_GENERR;
    }
    return SNMP_ERR_NOERROR;
}

int
handle_enterpriseStartTime(netsnmp_mib_handler *handler,
                           netsnmp_handler_registration *reginfo,
                           netsnmp_agent_request_info *reqinfo,
                           netsnmp_request_info *requests)
{
    static U_INT temp_ntp_start_time;

    switch (reqinfo->mode) {
    case MODE_GET:
        snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
                                 (u_char *)&system_ntp_start_time,sizeof(U_INT));
        break;
    case MODE_SET_RESERVE1:
        break;
    case MODE_SET_RESERVE2:
        break;
    case MODE_SET_FREE:
        break;
    case MODE_SET_ACTION:
        if(system_ntp_daylight_saving == 0)
                netsnmp_set_request_error(reqinfo, requests,SNMP_ERR_NOACCESS);
        if (requests->requestvb->val_len == 0)
                return SNMP_ERR_GENERR;
        temp_ntp_start_time = *((long *)requests->requestvb->val.integer);
        if((system_ntp_start_month == system_ntp_end_month) && (system_ntp_start_week == system_ntp_end_week) && (system_ntp_start_day == system_ntp_end_day))
                if(temp_ntp_start_time >= system_ntp_end_time)
                {
                        netsnmp_set_request_error(reqinfo, requests,SNMP_ERR_WRONGVALUE);
                        return SNMP_ERR_WRONGVALUE;
                }
	if(requests->requestvb->type != ASN_INTEGER)
                netsnmp_set_request_error(reqinfo, requests,SNMP_ERR_WRONGTYPE);
        if(temp_ntp_start_time < 1 || temp_ntp_start_time > 24)
                netsnmp_set_request_error(reqinfo, requests,SNMP_ERR_WRONGVALUE);
        else
                system_ntp_start_time = temp_ntp_start_time;
        /*if we got broad, this will replace real "console timeout" function*/
        printf("set ntp time function\n");
        break;
    case MODE_SET_COMMIT:
        break;
    case MODE_SET_UNDO:
        break;
    default:
        return SNMP_ERR_GENERR;
    }
    return SNMP_ERR_NOERROR;
}

int
handle_enterpriseEndMonth(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info *reqinfo,
                          netsnmp_request_info *requests)
{
    static U_INT temp_ntp_end_month;

    switch (reqinfo->mode) {
    case MODE_GET:
        snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
                                 (u_char *)&system_ntp_end_month,sizeof(U_INT));
        break;
    case MODE_SET_RESERVE1:
        break;
    case MODE_SET_RESERVE2:
        break;
    case MODE_SET_FREE:
        break;
    case MODE_SET_ACTION:
        if(system_ntp_daylight_saving == 0)
                netsnmp_set_request_error(reqinfo, requests,SNMP_ERR_NOACCESS);
        if (requests->requestvb->val_len == 0)
                return SNMP_ERR_GENERR;
        temp_ntp_end_month = *((long *)requests->requestvb->val.integer);
        if(requests->requestvb->type != ASN_INTEGER)
                netsnmp_set_request_error(reqinfo, requests,SNMP_ERR_WRONGTYPE);
        if(temp_ntp_end_month < system_ntp_start_month)
	{
		netsnmp_set_request_error(reqinfo, requests,SNMP_ERR_WRONGVALUE);
		return SNMP_ERR_WRONGVALUE;
        }
	if(temp_ntp_end_month < 1 || temp_ntp_end_month > 12)
                netsnmp_set_request_error(reqinfo, requests,SNMP_ERR_WRONGVALUE);
        else
                system_ntp_end_month = temp_ntp_end_month;
        /*if we got broad, this will replace real "console timeout" function*/
        printf("set ntp month function\n");
        break;
    case MODE_SET_COMMIT:
        break;
    case MODE_SET_UNDO:
        break;
    default:
        return SNMP_ERR_GENERR;
    }
    return SNMP_ERR_NOERROR;
}

int
handle_enterpriseEndWeek(netsnmp_mib_handler *handler,
                         netsnmp_handler_registration *reginfo,
                         netsnmp_agent_request_info *reqinfo,
                         netsnmp_request_info *requests)
{
    static U_INT temp_ntp_end_week;

    switch (reqinfo->mode) {
    case MODE_GET:
        snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
                                 (u_char *)&system_ntp_end_week,sizeof(U_INT));
        break;
    case MODE_SET_RESERVE1:
        break;
    case MODE_SET_RESERVE2:
        break;
    case MODE_SET_FREE:
        break;
    case MODE_SET_ACTION:
        if(system_ntp_daylight_saving == 0)
                netsnmp_set_request_error(reqinfo, requests,SNMP_ERR_NOACCESS);
        if (requests->requestvb->val_len == 0)
                return SNMP_ERR_GENERR;
        temp_ntp_end_week = *((long *)requests->requestvb->val.integer);
        if(requests->requestvb->type != ASN_INTEGER)
                netsnmp_set_request_error(reqinfo, requests,SNMP_ERR_WRONGTYPE);
        if(system_ntp_start_month == system_ntp_end_month)
		if(temp_ntp_end_week < system_ntp_start_week)
		{
                        netsnmp_set_request_error(reqinfo, requests,SNMP_ERR_WRONGVALUE);
                        return SNMP_ERR_WRONGVALUE;
                }
	if(temp_ntp_end_week < 1 || temp_ntp_end_week > 5)
                netsnmp_set_request_error(reqinfo, requests,SNMP_ERR_WRONGVALUE);
        else
                system_ntp_end_week = temp_ntp_end_week;
        /*if we got broad, this will replace real "console timeout" function*/
        printf("set ntp week function\n");
        break;
    case MODE_SET_COMMIT:
        break;
    case MODE_SET_UNDO:
        break;
    default:
        return SNMP_ERR_GENERR;
    }
    return SNMP_ERR_NOERROR;
}

int
handle_enterpriseEndDayOfWeek(netsnmp_mib_handler *handler,
                              netsnmp_handler_registration *reginfo,
                              netsnmp_agent_request_info *reqinfo,
                              netsnmp_request_info *requests)
{
    static U_INT temp_ntp_end_day;

    switch (reqinfo->mode) {
    case MODE_GET:
        snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
                                 (u_char *)&system_ntp_end_day,sizeof(U_INT));
        break;
    case MODE_SET_RESERVE1:
        break;
    case MODE_SET_RESERVE2:
        break;
    case MODE_SET_FREE:
        break;
    case MODE_SET_ACTION:
        if(system_ntp_daylight_saving == 0)
                netsnmp_set_request_error(reqinfo, requests,SNMP_ERR_NOACCESS);
        if (requests->requestvb->val_len == 0)
                return SNMP_ERR_GENERR;
        temp_ntp_end_day = *((long *)requests->requestvb->val.integer);
        if(requests->requestvb->type != ASN_INTEGER)
                netsnmp_set_request_error(reqinfo, requests,SNMP_ERR_WRONGTYPE);
        if((system_ntp_start_month == system_ntp_end_month) && (system_ntp_start_week == system_ntp_end_week))
		if(temp_ntp_end_day < system_ntp_start_day)
		{
                        netsnmp_set_request_error(reqinfo, requests,SNMP_ERR_WRONGVALUE);
                        return SNMP_ERR_WRONGVALUE;
                }
	if(temp_ntp_end_day < 1 || temp_ntp_end_day > 7)
                netsnmp_set_request_error(reqinfo, requests,SNMP_ERR_WRONGVALUE);
        else
                system_ntp_end_day = temp_ntp_end_day;
        /*if we got broad, this will replace real "console timeout" function*/
        printf("set ntp day function\n");
        break;
    case MODE_SET_COMMIT:
        break;
    case MODE_SET_UNDO:
        break;
    default:
        return SNMP_ERR_GENERR;
    }
    return SNMP_ERR_NOERROR;
}

int
handle_enterpriseEndTime(netsnmp_mib_handler *handler,
                         netsnmp_handler_registration *reginfo,
                         netsnmp_agent_request_info *reqinfo,
                         netsnmp_request_info *requests)
{
    static U_INT temp_ntp_end_time;

    switch (reqinfo->mode) {
    case MODE_GET:
        snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
                                 (u_char *)&system_ntp_end_time,sizeof(U_INT));
        break;
    case MODE_SET_RESERVE1:
        break;
    case MODE_SET_RESERVE2:
        break;
    case MODE_SET_FREE:
        break;
    case MODE_SET_ACTION:
        if(system_ntp_daylight_saving == 0)
                netsnmp_set_request_error(reqinfo, requests,SNMP_ERR_NOACCESS);
        if (requests->requestvb->val_len == 0)
                return SNMP_ERR_GENERR;
        temp_ntp_end_time = *((long *)requests->requestvb->val.integer);
        if(requests->requestvb->type != ASN_INTEGER)
                netsnmp_set_request_error(reqinfo, requests,SNMP_ERR_WRONGTYPE);
         if((system_ntp_start_month == system_ntp_end_month) && (system_ntp_start_week == system_ntp_end_week) && (system_ntp_start_day == system_ntp_end_day))
                if(temp_ntp_end_time <= system_ntp_start_time)
		{
			netsnmp_set_request_error(reqinfo, requests,SNMP_ERR_WRONGVALUE);
			return SNMP_ERR_WRONGVALUE;
		}
	if(temp_ntp_end_time < 1 || temp_ntp_end_time > 24)
                netsnmp_set_request_error(reqinfo, requests,SNMP_ERR_WRONGVALUE);
        else
                system_ntp_end_time = temp_ntp_end_time;
        /*if we got broad, this will replace real "console timeout" function*/
        printf("set ntp time function\n");
        break;
    case MODE_SET_COMMIT:
        break;
    case MODE_SET_UNDO:
        break;
    default:
        return SNMP_ERR_GENERR;
    }
    return SNMP_ERR_NOERROR;
}

int
handle_macFilterType(netsnmp_mib_handler *handler,
                     netsnmp_handler_registration *reginfo,
                     netsnmp_agent_request_info *reqinfo,
                     netsnmp_request_info *requests)
{
    static U_INT temp_mac_type;

    switch (reqinfo->mode) {
    case MODE_GET:
        snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
                                 (u_char *)&advance_mac_filter_type,sizeof(U_INT));
        break;
    case MODE_SET_RESERVE1:
        break;
    case MODE_SET_RESERVE2:
        break;
    case MODE_SET_FREE:
        break;
    case MODE_SET_ACTION:
        if (requests->requestvb->val_len == 0)
                return SNMP_ERR_GENERR;
        temp_mac_type = *((long *)requests->requestvb->val.integer);
        if(requests->requestvb->type != ASN_INTEGER)
                netsnmp_set_request_error(reqinfo, requests,SNMP_ERR_WRONGTYPE);
        if(temp_mac_type < 0 || temp_mac_type > 2)
                netsnmp_set_request_error(reqinfo, requests,SNMP_ERR_WRONGVALUE);
        else
                advance_mac_filter_type = temp_mac_type;
        /*if we got broad, this will replace real "console timeout" function*/
        printf("set mac filter type\n");
        break;
    case MODE_SET_COMMIT:
        break;
    case MODE_SET_UNDO:
        break;
    default:
        return SNMP_ERR_GENERR;
    }
    return SNMP_ERR_NOERROR;

}

int
handle_webFilterType(netsnmp_mib_handler *handler,
                     netsnmp_handler_registration *reginfo,
                     netsnmp_agent_request_info *reqinfo,
                     netsnmp_request_info *requests)
{
    static U_INT temp_web_type;

    switch (reqinfo->mode) {
    case MODE_GET:
        snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
                                 (u_char *)&advance_web_filter_type,sizeof(U_INT));
        break;
    case MODE_SET_RESERVE1:
        break;
    case MODE_SET_RESERVE2:
        break;
    case MODE_SET_FREE:
        break;
    case MODE_SET_ACTION:
        if (requests->requestvb->val_len == 0)
                return SNMP_ERR_GENERR;
        temp_web_type = *((long *)requests->requestvb->val.integer);
        if(requests->requestvb->type != ASN_INTEGER)
                netsnmp_set_request_error(reqinfo, requests,SNMP_ERR_WRONGTYPE);
        if(temp_web_type < 0 || temp_web_type > 2)
                netsnmp_set_request_error(reqinfo, requests,SNMP_ERR_WRONGVALUE);
        else
                advance_web_filter_type = temp_web_type;
        /*if we got broad, this will replace real "console timeout" function*/
        printf("set web filter type\n");
        break;
    case MODE_SET_COMMIT:
        break;
    case MODE_SET_UNDO:
        break;
    default:
        return SNMP_ERR_GENERR;
    }
    return SNMP_ERR_NOERROR;

}

